08/28/2018
What to do regarding software for generating voice-leading patterns? Hmm... What is it I really want here...? I want to give the software a voicing and cycle pattern (i.e. 7/2, 4/5, or
3/6) and have it generate the corresponding chord progressions in all the keys. What about restricting things based on the layout of the guitar neck? Should I apply some sort of rules
based on which string set the exercise is to be done on? Hmm... It would be simple enough to generate the pattern and then transpose chords down or up an octave if they're out of range
of the strings in the set that has been selected. The ranges might move around a bit depending on the voicings selected... hmm... how do we cycle through the voicings? How is the next
note selected each time? Hmm... That will depend on which type of cycle you're using.

7/2 cycle - move all the notes
5/4 cycle - move two of the notes
6/3 cycle - move one of the notes

The exact details can be worked out more once you get a few examples on paper to work through...

How do I define the set of available notes to use so this can facilite using the melodic minor/harmonic minor scales (and any of the other modes potentially)? You could use an ordered
data structure. There might be something in music21 which already facillitates this.

Hmm... What was the logic behind the patterns Chris began with? Hmm... Well looking at the scores it looks like one way was descending of the two but the other was ascending in general

Cycle 2:Descending	-	Cycle 7:Acsending
Cycle 4:Ascending	-	Cycle 5:Descending
Cycle 3:Descending	-	Cycle 6:Ascending

Hmm... Why would the directions cycles switch based on the 4/5 pairing? Hmm... I'm not sure I understand the inital logic of the chord progressions themselves enough to see it right now.
Hmm... I think that's just a quirk of the relationship between chords a 4th apart... Especially if you hold common tones and move... But why...? What are the notes involved in terms
of scale degree functions...

I = 1 3 5
ii = 2 4 6
iii = 3 5 7
IV = 4 6 1
V = 5 7 2
vi = 6 1 3
vii = 7 2 4

1-w-2-w-3-h-4-w-5-w-6-w-7-h-8

Hmm... Yeah I don't think it has to do with the diatonic order directly... but just looking at the scale degrees involved in spelling the tones are very closely related... 1 chord one
is common and the other two are only a step away... I'll just leave that to be a quirk of the system for now as I've got other things to take care of... What was I doing again? Yes...
what are the rules which will govern how the different cycles operate in terms of note movement... Cycle 3/Cycle 6 seem easiest as only one note moves at a time... Hmm... I wonder if
there's some sort of chord comparsion function provided in the music21 library which would allow me to do that automatically...

Cycle 3 Pattern:	Bottom note moves down one scale degree (is that the right term? look this up later...)
					Middle note moves down one scale degree
					Top note moves down one scale degree
					This pattern looks like it repeats (I'm too lazy to check every single chord change...)
Cycle 6 Pattern:	Top note moves up one scale degree
					Middle note moves up one scale degree
					Bottom note moves up one scale degree
					There are no leaps beyond a step in any of the voice leading lines (beyond the tranposition when things go out of range)
Cycle 4 Pattern:	Bottom note is held, top and bottom voices move up one scale degree
					Middle note is held, top and bottom voices move up one scale degree
					Top note is held, middle and bottom voices move up one scale degree
Cycle 5 Pattern:	Top note is held, middle and bottom voices move down one scale degree
					Middle note is held, top and bottom voices move down one scale degree
					Bottom note is held, top and middle voices move down one scale degree
Cycle 2 Pattern:	Top and middle notes move down one scale degree, bottom note moves down two scale degrees
					Top and bottom voices move down one scale degree, middle voice moves down two scale degrees
					Middle and bottom note move down one scale degree, top voice moves down two scale degrees
Cycle 7 Pattern:	Middle and bottom voices move up one scale degree, top voice moves up two scale degrees
					Top and bottom voices move up one scale degree, middle voice moves up two scale degrees
					Top and middle voices move up one scale degree, bottom moves up two scale degrees
					
Hmm... I think I've got a good start here... It's time to get the code up and running to see what I can do and if I was right...

Hmm... Do I do this with chord or scale objects...? Let's take a look to see what the difference is... Hmm... It seems the best way to do this (at least following the method I have in
mind) is to use the scale object and use it to generate notes...??? Hmm... How do I do this? Extract a pitch each time? Have three separate objects? Have something keeping track of
each different voice...? Is there a method to take a pitch from a class and then have it remember it's part of a set of pitches from a scale? Hmm... IIRC the scale objects are formed
by a set of intervals or Interval Network.... Hmm... Was that a concrete or abstract scale? I would need a concrete scale as there would be a key... It appears as if the next() function
will allow me to do this...

Hmm... Would it be better to keep track of all the pitches in a chord object? Also will the pattern that the voices move stay the same depending on the voicing? I think not, the
relationships are more based on the tonal functions of the notes in each chord. How will I be able to do this more systematically and using music theory more than identifying patterns
... Although I'd bet the same patterns of note movement apply based on which part of the chord each note is (i.e. the 3rd always follows the same path but it changes by octave)...
I'll have to have some way of indicating which notes are moving each time and by how much... some sort of data structure which keeps track of the number of scale degrees to change
for each note...

Also, how do I store all the cycles and chords generated? hmm... it seems like this is something I could do easily with chords... although I could create a new chord with the new set
of pitches each time... hmm... But then if I modify the pitches would that modify the chord...? I can't remember exactly how music21 handles storing copies of things... I believe it
was a bit unorthodox and I'm not sure I fully understand their reasoning... I'll have to look into this...

Hmm... How is it that music21 stores it's stuff again...? everything is a stream? I'll need to make several measures (in 7/4) and then have those in a larger stream...

09/03/2018
What about 7ths and 6th chords? Adding another scale degree will add another voice to follow and (correspondingly have another path to deduce)... What about the harmonic minor/melodic
minor scales? Hmm... since we're dealing with tertiary harmony (although sus2 and sus4 chords will be slightly different...) and the harmonic movement is based on the relationships of
the scale degrees, as long as we have a data structure which keeps track of the scale degrees/note ordering properly (and keep it just to diatonic scales atm) then the actual scale
structure shouldn't be necessary to worry about... the system will take care of itself. I'll just have to work through one example with 7th chords in order to figure out the path for
each note (6ths can be added later as after learning 7ths it would proabably be easy to pick them out on the fly).

Hmm... What to do now... Is there any good software out there that could help me keep track of the tasks I have left to do? Well what is it that I have to do? Hmm... I still need to
explore the music21 library to figure out the best way to implement the ideas I have here... Hmm... it looks like creating a chord each time would be best... It doesn't look like 
there are any easy ways to quickly modify the notes of a chord...

12/12/2018
Hmm... It's been awhile but I think what is necessary is to create something which keeps track of an ordered set of pitches (i.e. a concrete scale object) and then have three different
"pitch pointers" so to speak... these data structures will represent the pitches as they move throughout the scale... I'm not sure how the exact details work but I have a good rough
idea... let's first try and create this and build from there...

what do i want in a pitch pointer? it keeps track of the index in the larger structure of what pitch to select... what if I go backwards? where do i start within the scale to make
sure I have enough room... hmm... what about using the scale.next() method...? is there a corresponding ".previous()" method? there is!!! praise jebus!!! I really need to experiment
more with using this and the scale object, also... what about what note do I start on? Ultimately this will be determined by the string set being used but for now I can just use
any starting pitch and then adjust this later...

ConcreteScale.next(pitchOrigin=None, direction='ascending', stepSize=1, getNeighbor=True)

That is the function we want...

12/13/2018
Hmmm... How do I store the information which dictates the way each note should move in a compact/easily accessible form? How will this be used? There will be an integer associated with
each chord tone that will be passed to the .next() function. When 4-note chords are added, this will have to be expanded slightly... For now don't worry about that and just focus on
getting the triads working correctly... What type of data structure would be best here? Hmm... This is really a choice based on my comfort/familiarity with Python... A 3x3 matrix would
probably do it...  3 entries in each row for each chord tone, and 3 columns as there are 3 steps until the pattern repeats...

Hmmm... Now I need a way of iterating over the larger structure... It seems splitting up the loops as I have done will create a lot of unecessary corner cases... I believe there is a
much cleaner solution to this problem... What do I want to do? It seems there's an issue since the number of transpositions necessary to complete a a cycle doesn't always correspond
with the number of chords per measure (i.e. 3 tranpositions v.s. 7 chords per measure)... how do I compactly represent this information in a loop?  I'll also have to change the 
measure which is being updated each time...

10/22/2020
Hmm... Okay.. What do do next... Well where was I with this project to begin with? Hmm... When I type show something pops up but it disappears quite quickly... Hmm... Perhaps it has to
do with my music21 configuration... Hmm... it might be worth updating my music21 libary to make sure I have the latest code... They seem to have added a lot of things which could be
useful... Hmm... So the music is displaying now, that is useful... Hmm... Okay... What is this and how is it useful? It looks like this is a cycle two ascending... Why is that? I mean
I shoudl go back through it and see what's up to make sure I'm identifying it correctly... Hmm... It looks like a cycle two but I'd have to learn the properties of a cycle two to be
more sure of what it is I'm looking at... Hmm... What was the goal here again? It has been awhile since I worked on this... Ahh... I want it to generate all the different progressions
in any key. Ahh... And then if memory serves correctly there are ways of linking the various cycles together... I can work on imposing the various restrictions regarding the string
changes after I get the basic stuff working... Hmm... What is it I want to do here? Hmm... Let's get a full cycle generated...

Hmm... this seems to have gotten more complicated... What I need to be able to do is figure out how to generate the next chord in the cycle and move it up and octave... Hmm... Yes...
My thinking just changed a bunch here... there's no point in doing it this way... I think what I could do is create functions to generate these various aspects... Hmm... Yeah, you could
pass it a starting chord and a cycle type and it would generate the corresponding cycle. This would be a lot easier and cleaner. From there if I wanted to generate the whole thing I'd
need to just do it by generating another progression but using the chord inversion i'm interested in to start with...

10/26/2020
So I'll work on developing the code to generate one complete cycle from a given chord... Hmm... Yes I reckon I definitely need to start on the tonic chord. That makes a lot of sense 
here... Hmm... what exactly does this matrix represent again? Got it... Hmm... so how do we generate the different notes here? Ahh... I need to manipulate the "pitch pointers" to generate
each of the different chords I'm looking for...  Hmm... I believe I could write these loops a lot cleaner based on the more powerful python iteration methods... So what is it I do now?
I use the cycle matrix to generate the different chords I'm looking for based on the starting_chord. So I take... Hmm... so I also need a way of making sure that the pitch order as
well as the element in each of the elements in the cycle matrix are changed... Hmm... Interesting... I believe there's a way to traverse both at the same time in Python... Hmm... I'm not
sure what's going on here... It might be worth creating a new data structure in here to copy the chord tones into... Hmm... That seems like it might do the trick... Hmm... is there a
way in music21 to convert a chord to a list of pitches?

Son of a bitch... it looks like there's another set of patterns for the different starting chords? or is there? I think i was able to generate a 21 chord sequence before... I'm not 
sure why I wouldn't be able to now...

10/28/2020
Hmm... okay... So these are all definitely permutations of the same matrix I believe... Hmm... so I believe this is correct... I'll need to test it out starting on the first inversion
chord... Hmm... I'm not sure if I'm liking this documentation here... There should be... Ehh... This works for now... Hmm... What is the next step? It would be nice to make sure this 
works in all keys. Hmm... I'd also need the functionality in place which makes it I can generate chord scales regardless of what 

Functionality Required:
 - Generate chord scales for arbitrary keys
 - Adjust chord scales to fit the ranges for particular sets of strings
 - Generate chord scales for major/harmonic/melodic keys
 - Geneate chord scales for the following cycles - done
	cycle 2
	cycle 7
	cycle 4
	cycle 5
	cycle 3
	cycle 6
 - Generate chord scales for arbitrary voicings (drop 2 and drop 3) - done
 - Generate chord scales for 7th chords
 
Hmm... So what should I do next? I'll clean this code up a bit... I should make sure I'm doing things as efficiently as possible... The first part would be to change these matricies
so they're just permutations of the first one... Hmm... I might even be able to generate the cycle 7 matricies as permuations of these... better not optimize too much at the moment...
Hmm... so i've got that part down... now let's focus on getting the other cycles in place... cycle 7 seems like the next best place to start

10/29/2020
Okay, lets work on getting the cycle 3 and cycle 6 chords generated... Hmm... A lot of this all depends on how you define what a cycle is. Is a cycle one smaller 7 chord sequence or
is this more something elaborate? Like we get all the way back to a root position triad for the starting point...? Hmm... Interesting question... I can contemplate that more later
after I figure out these basic cycle sequences... Hmm... Looks like I've got all the various cycles down... Lets take a look and refactor this into something we can use for the various
other parts. Hmm... How should this work? I could take all these various constituent functions and data structures and put them in a module. From there I can create a script which 
calls and uses the functions accordingly. That makes a lot of sense to me... Hmm... that's an interesting question... Will the cycle matrices stay the same for the harmonic and melodic
minor variants? I'm tempted to say yes as this is all based on tertian harmony and the movement of the various scale degrees. If those scales are harmonized in thirds and then the corresponding
notes are moved accordingly I think it would be similar... Hmm... It would be fairly simple to try, however I unfortunately don't have a set of written out examples to compare it to...
However I would be able to do this fairly easily from a music theory standpoint... Hmm... However... Before I get too far into it, it would be worth making sure that I'm doing things
correctly from the standpoint of music21 before I make this thing any larger... Hmm... It would also be useful to generate the full "21" chord cycles from one function call... Hmm...
These are good tasks to focus on while I'm building these things up...

10/30/2020
Okay... Let's work on developing these chord scales for different voicings... Lets tackle the drop 2 voicings first... Hmm... How do I do this? Might it be easier just to take one of
the pre-configured/generated scenarios and then just take one the middle note and move it down an octave? Hmm... How would I go about doing that? I would need to go through each measure
and each chord and get the middle note of each chord and move it down... Hmm... Or I could attempt to use a different starting pitch and then change the different cycle matricies around...
I mean both options seem equally valid... Although it might be easier to try and move the matricies around first... Hmm... I think it would work... I would just have to match things 
so the rows would correspond to the same starting scale degree... Would that necessarily be easier than just going through all the chords in a sequence and moving a voice down an octave?
I think not... Hmm... Especially as we could make a function to do that and then pass a parameter to determine what note is transposed down an octave... That honestly seems like a much
better approach to this... Although it would be worth cleaning things up and encapsulating some of the functionality here a bit better... hmm... how do I do this? have several calls 
to generate_cycle I would reckon... 

Hmmm... So what is meant by a full cycle here? This would be a complete cycle of 21 chords without any sort of tranposition between the chords. Hmm, it's probably better to pass a string
which indicates the cycle type... Hmm... This is a bit messy as some of the patterns deviate a bit... hmm... I still need to make the cycle 6 chords however... Hmm... However there 
are the two different ideas here of a cycle. Like you can have a full cycle for cycle 2 developed and then there's a cycle 7 which comes afterwards to make a whole complete exercise
in both directions... That would be interesting... so what do I call these two ideas? There are "full cycles" as well as "full exercises"? Hmm... I'm not sure if that's the best name
for these things but it's definitely a start... Hmm... is there some sort of a programming construct which could be applied here? It seems a bit redundant to go ahead and complete a
bunch of other if statements again... although that's all I have in mind at the moment... well this is a first draft so it's likely to be changed a whole bunch in order to figure things
out... hmm... what is it i'm trying to do here? I want to be able to select which matrix is passed each time... hmm... another layer of indirection might help here but i'm not sure
how useful it would be... unfortuantely it's not as simple as selecting just one variable type... Hmm... however... I could make a multidimensional list... I mean I've already created
a multidimensional list but this would be a three dimensional list... Hmm... although if all the permuations as based on one matrix and they're the same for the two large classes of 
cycles then I'd be able to use that information to generate what i need...

10/31/2020
Hmm... So how do I create a three dimensonial list here? Hmmm... how do I construct this? Do I create an empty list or is this something which can be dynamically generated? Hmm...
Interesting question... Hmm... so it looks like I've figured out how to organize these... I'll do them in isolation and then integrate everything into the main code base... Hmm... 
What would be the advantage to using numpy arrays here? Well it might be easier to encode these matricies using actual matricies... Plus it would be easier to perform all these different
operations on each matrix based operations I reckon... Hmmm... I should just open it up and try and do that... 

Hmm... Yes, I'm liking numpy quite a bit more here for the arrays. However, hmm... how do I do this? Do I define all the cycle 7 matrixes based on what the initial cycle 2 ones were
or do I do it based on the initial cycle 7 matrix? Hmm... I mean this one is definied by the cycle 2 in it's own way. Roughly speaking what you have is several different permutations
of the same rows. Hmm... I could see it being done either way... Although it might be nice to have the cycle 7 one listed out explicitly... However if there are any changes to the 
cycle 2 matrix then it would be nice to have these propagate throughout the rest of the system... But the odds of it changing are relatively small to begin with... I mean it would be
interesting to note the relationship exactly between the cycle 2 and cycle 7 matricies however it seems like it's something that can be explore much later on...

Hmm... Okay... Now that I have these new data structures representing the matricies I need to figure out how to integrate them into the rest of the system...

Hmm... What to do for this next? I need to figure out how to iterate through these data structures so I can incorporate them into the rest of the program I wrote... Hmm... I think I
might be able to use the exact same program... I'm not sure how many modifications are needed... Hmm... it seems as if they fit quite nicely... 

So how do we do this full cycle thing? Is there a way to check which data structure was passed? Hmm... Well there is a nice comparison function for the whole array... how are these
results then interpreted?

11/01/2020
Hmm... Okay, what's the next step? Well let's straighten out the full_cycle generation function so that it starts at one octave and then doesn't need to be adjusted at all... It should
be one continuous cycle that is then adapted/adjusted based on the range needs of whatever instrument is it being played on (or whatever the constraints that need to be added are).
Hmm... I'm not entirely sure how this inversion function works... I should look into this... Hmm... The inversions seem to be done based on moving the notes up an octave. Hmm... I 
mean that makes sense to an extent as that's how things are traditionally taught... However it would be a nice feature if you could say which way you want to achieve the inverison...
By that I mean which direction you want the notes to go. It doesn't seem to try and find the easiest path in terms of inversion generation... Although this doesn't really explain
why I'm getting massive octave jumps here... I'll have to use a breakpoint to figure it out... ahh, I see why these inversions are being created like this... Hmm... Perhaps generating
the sub-cycles isn't the best approach here... It might be to iteratively apply the cycle matrix, or it might be easier to pass deep copies so this situation doesn't arrive... Hmm...
how do I do this in a way though where I don't modify the originally passed chord? Hmm... Although that's an intersting question... Is that what I want? I mean it would be nice to do
that and have it so there's no modification to the passed chord... Although... Hmm... I wonder why they do things in this manner? I can see how it might be better to be able to make
an adjustment to one object and since everything is a reference then everything else would adjust accordingly... That might make it a bit tricky in larger programming contexts however...
Hmm... yes... it appears the deep copy method worked... What to do next? I would like to be able to generate the ascending and descending pairs like in the Chris Buono exercises...

So this would be a function which generates an ascending cycle followed by a descending cycle. the three different types are:
 - cycle 2/7
 - cycle 4/5
 - cycle 3/6
 
Hmm... this is where the Buono examples break down as they were designed to be played all over the guitar neck... Hmm... the nature of the cycles will become more evident as I generate
these different exercises but for the 3/6 ones it looks like you start at one octave and then end on another... it would be worth exploring the other cycle pairings hmm... this is what
i thought might happen... i need to figure out how to append these various cycles together on a measure basis... hmm... I would need to learn the various heirarchies of the stream,
measure, part and all that in order to figure out how these things work... Hmm... it might be better to change the other storage types to streams... or perhaps a list of measures...
I'm not entirely sure... That would be something which would be interesting and worth investigating...

11/02/2020
Hmm... I need to be able to indicate that these are measures of 7/4. How do I do that? That would likely be in the subcycle function... Hmm... It might be good to develop a test module...
Essentially just a collection of tests on the various pieces of functionality here... Hmm... Theoretically I should just be able to iteratively apply these matricies... That would make
things a whole lot easier for being able to generate one particular "full cycle" meaning a 21 chord sequence which follows the same progressions... Hmm... do these patterns which I noted
before apply every time? I think so... In fact it would be easier to do it without having to deal with the inversions as it will make the code more consistent across different voicings...
Hmm... Although here it would be useful to operate on the chord which has been passed so after the cycle has been done in one direction then you just take that same chord and feed it
as the starting parameter to the next one... hmm... Yeah, I'm fairly certain that will work...

Hmm... This is an interesting puzzle, the tricky part will be figuring out how to translate this into a loop...
Hmm... If I append a time signature of 7/4 to the stream, will everything take care of itself basically?

Hmm... I think the best way to do this would be to create a larger loop which handles the total number of chords for the iteration and then... hmm... so 0-20 will be 21 iterations...
we want 20 so I should go 0 to 19... I was wrong there... 0 to 20 is what we want as the end isn't included

Hmm... What about the ending chord? How do we want to do this? I'm not sure if the chord itself is used/modified... it most definitely is not as we first turn it into a list of pitches
and then begin modifying it... hmmm... how ever it each of those pitches are referenced in the original chord structure then what's up with that...? Hmm... well what we do is completely
change the chords in the list...

Hmm... I'm not sure what to do for now... I can always go back and change things... it would also definitely be super useful to encapsulate this "row" functionality... in terms of 
applying a row to a chord as a list... Hmm... I wonder why the extra treble clefs are being added... Hmm... this is a fairly small issue and can be dealt with later... the core of
the functionality is there that i need and i can develop all the rest of what i'm working on here...

11/04/2020
Hmm... It definitely seems like the basic cycle pairs have come out correctly. Okay.. What's the next step? I think the next step would be to generate these for different chord voicings.
Hmm... How would that necessarily differ? I mean the same relationships in terms of the movement of each voice would be the same I think. What is iddferent is identifying the starting
note of each "row". Or each chord perhaps is a better way to put it... Let's write one out to make sure you see how it works... Hmm... What does this effectively change to? Ahh... In 
terms of the matrix operations this can be acheived by swapping columns. And this makes sense as each column represents the relative position vertically of each note. Each row represents
the motion of the tone in each transition. Hmm... How would I acheive this more easily? Also, what about the drop 2 and drop 3 voicings. Hmm... I don't see any harm in necessarily 
creating drop 3 triads... Hmm... Although forming the various inverions here would be difficult. Hmm... That might be why they're not used as much... Or it might be why they're not
labeled in the same way. If I did this, all I would get is the same thing but with a note an octave down. Hmm... Although it makes sense in a certain way. You don't use the same rules
as for the closed voicings since you have compound intervals. However if you have a "seed triad" and then generate the voicings from them by moving each note to the next chord tone 
ascendingly then you can generate the voicings in a similar manner. Hmm... Interesting... Especially interesting as since the chord tones appear in the same order, just with an octave
in between them, theoretically I could use the same cycle matrix to generate them. Hmm... yes, I see why this wouldn't work. It might be necessary to generate them intervallically.
Hmm... Although where do you stop... I mean you could also generate voicings by adding another octave between any of the notes... Hmmm... I mean theoretically you would have a "raise
1" if you went the other route and had the octave added to the G. Hmm... I mean it's not as if these voicings aren't necessarily useful... However... Hmm... Yes, these are interesting...
exercises... I especially like how they sound on my acoustic... However unfortunately it seems as if my acoustic needs a bit of work... Hmm... So this seems to have worked... Interesting...
I wonder if the same rules regarding the inversions for reversing the cycles applies. This is quite possible. If so I would be able to darastically change some of the functions and make
things a whole lot more efficient... Hmm... Man, I could save a lot of time here by just applying the column swapping matricies based on the permulations of the identity matrix. Although
I would need to tranpose it first as the permutation matricies only apply to row operations it seems. How do these apply to three dimensional matricies? Hmm... It doesn't seem like
that is necessary really... I can just change the order of matrix multiplication in order to achieve this.

11/08/2020
Okay... So how to modify the code to generate the various other parts... By that I mean how do I modify the code in order to make it so I can generate the cycle pairs using the swapped
matricies more easily? Hmm... Adding a flag to trigger the drop 2 aspect would be a good way. Hmm... Why is this Ab showing up as as G#? That shouldn't be... Is this a music21 problem
or a MuseScore problem? Hmm... This seems to be a bug within the music21 library itself... Calling transpose(0) turns the Ab into a G#. This should not be... Deep copy seems to be a 
better way of handling this... Hmm... I mean strictly speaking this did give me the melodic minor harmonization in a way (there is different behavior when the scale is ascending compared
to when it is descending). I wonder why this didn't occur with the harmonic minor scale... That's a good question... 

11/09/2020
Hmm... Is there a way to create your own scales here? That would be nice as I could theoretically create a melodic minor style scale to be able to acheive what it is I want to do here.
Hmm... I mean theoretically I could make a function to reverse a sequence. Hmm... I mean that would be fairly useful as I could re-write this function to be even more generalized and
it wouldn't require have a type specified. Hmm... Although I would still have the issue of generating arbitary chord scales, hmm... it seems as if 

11/14/2020
Hmm... What to do here? I should get the melodic minor scale working. It would really be ncie to have everything conform to the same interface so it makes it easier to work with everything.
Hmm... Okay... I think there's a way to create a scale which operates in a similar fashion to what I'm looking for... Hmm... What to do here? It might be easier just to use a basic
scale and let the user define it to whatever they want it to be. This would make things easier since you could define whatever arbitrary scale you want to use. Some of these matricies
would only be so useful since since they apply to your basic diatonic scales. But that makes sense to develop those ideas first. Hmm... I believe I have the basics working here... I mean
to truly understand the various differences between the different scale harmonizations would require a lot more studying of them. Hmm... But I believe I have the basics of the arbitary
scale as well as the harmonic minor scale at the moment... That's good! Ultimately the more I use the tool and test it, the more the different bugs and kinks will get worked out...

Hmm... How would I generate chord scales for arbitary voicings? That's a good question... I mean I'd need to rewrite some of the cycle matrices in order to achieve this. That's another
task in and of itself. I'd say I have a fairly good idea of how to do this. Hmm... Yeah... It's probably better to generate these different matricies based on modifying the current ones.
Hmm... Makes sense. I could write out the matricies for 7th chords and then modify them to generate chord scales with 6ths. I could also write out the matricies for 7th notes and then
pass in a smaller matrix from this for the triads. Hmm... I'm not sure what the best approach is at the moment. But it looks like I have a clear idea of what would be next. Those two
features are roughly orthogonal I reckon. 

Hmm... I'm not sure how to approach this range issue. I mean each note would have to appear on a different string. I could define some sort of
a string object or something and once the range is violated on any one of the strings by any one of the notes then we transpose it up or down an octave depending on what's going on.
That seems to be a fairly straight forward way of approaching the range issue.

Hmm... What about this 7th chord issue? I mean this opens up a lot more different possibilties for the various types of drop chords. I mean I think the best thing to do here would be
to write out an example of the progression to see exactly how many entries in the matrix would be necessary. You have to include motion for an extra note. Is there a forth row then as
well or just a 4th column? I think there might be a fourth row as things would expand a bit and there's an extra inversion... I suppose there's only one way to find out... Hmm... What
were the tricks which Chris Buono was using to generate the triad chord scales? I guess I'd have to go back and watch the videos.... Hmmm... It seems as if this Ed McGuire book has them
written out... This is probably something worth looking at much more closely. It definitely seems a lot mroe complicated than I was originally thinking... I think the range issue would
be the next thing to tackle. Afterwards, I can revisit these different chord scale ideas to try and figure out the best way to generate different voice leading patterns for them.

11/20/2020
Okay, so lets try and figure out how to approach the range issues and make it eaiser to play the patterns on a set of strings which are inherently finite. Hmm... So how would we do this?
Should we generate the cycle and then go through it chord by chord to transpose them all as need be? Hmm... what about checking the range of the chords while the cycle itself is 
actually being generated? That would be an interesting approach and probably a lot more efficient in certain regards. After we transpose it up/down an octave we could then pass the new
chord to the next part of the algorithm so it could continue on its merry way as it operates on a per chord basis. Hmmm... Yeah, that makes a lot more sense to me at this point. If I
consider the other option then it would be hard to figure out when we need to stop transposing. Or would it? I reckon it would be comparatively althgouh I'd need to write out an example
and compare the two approaches to be able to say for sure... it seems like right after apply_row_to_chord() would be the best place to add the range checking it might get tricky adding
the range checking feature to the sub_cycle generator as well. But let's keep working and see what happens...

Hmm... So how do we represent this concept of range here? It would likely involve two pitch objects, one for the start and one for the end of the range. How do we do this for the different
strings? Well each string will have it's own range. We will just need to figure out how to assign a string to each of the different voices of the chord. Hmm... Makes sense... Do we add
the open strings? Hmm... I mean it might be an iteresting way to approach studying these. I can say I really see a point in not including them (beyond just adhering to a particular rule).
It would make an interesting exercise to properly mute things and make sure you play the voicings correctly... That's just an arbitrary configuring of the range parameter however. Hmm...
That should be fairly easy to fix. Hmm... However how does this algorithm work? So we look at each note and see if it is out of range for the string it should be on. Once we've done that
then we determine whether or not to transpose it up or down an octave. Hmm... Yeah, I can see how this works... 

So how do we create a range here? And then how do we create a model of the guitar's range... Each string effectively has it's own range. These would then be used to figure things out.
Hmm... we need some sort of a pitch comparison function here... I wonder if music21 has anything for that... Looks like they do... And they even have something which includes doing
the comparisons for enharmonic notes. This would definitely be useful for our purposes... it looks like that's exactly what I'm looking for... the .ps attribute returns a float corresponding
to some sort of pitch space concept... So how do I do this and what is meaningful for our purposes here? and what do we want to return from the comparison function? we should have three
return values, in range, above range and below range. An enum would be nice here... Can I nest this inside the range class? Looks like I can... So how does this work? Pretty straight 
foward...

Hmm... okay... What to do next? Now that I have a range class I need to implement one for each string. Another class would be useful here for representing/storing the range of the guitar.
Theoretically this could be expanded quite a bit for ust about any other instrument... Now how do I do this. Hmm... It might also be easier to use a list here in terms of the ordering.
Then the numerical string value sets could more easily be computed/matched with the data structure... I can work on this tomorrow... It's getting close to bed time now...

11/21/2020
Okay... So let's take another look at this. Hmm... so how do I check to see if the chord is within the specified range? we'd have to have an ordered/corresponding pair of ranges to
match the order of the notes in the chord. hmm... i mean there are likely several different ways to go about this... 

11/23/2020
Hmm... I think the best way would be to solve this for a few of the most common cases and then try to generalize it from there... Let's do this for the 1-2-3 string set. Hmm... given 
that we're working with three note objects here then something like a 3 note tuple would be nice. Seems like a three element tuple would be what I'm looking for here... is it worth
enumerating all the various different string sets? possibly... so how do we check the range of each note? 

well we do have the chord as a list... ahh we could also use one of those things where we traverse multiple iterables at once... hmmm.... so what do I do now? I need to look at the 
return value and figure out what to do with it... hmmm... is there a possibility that after the transposition things won't work? well why would that work? that would mean that... hmm...
so there are three notes. well they would have to be some pretty strange voicings for that to occur. that shouldn't be happening with any of the voicings i've selected. I'm not quite
up to the task of figuring all that stuff out atm... 

hmm... that's a very good point to note here... should i be using the guitar pitches as they are written or as they actually are? becasue as they're written they're transposed up an
octave. hmm... given that i'm mainly using them to display things i don't think it matters if the notated pitch is different than the actual pitch...

11/24/2020
Hmm... So it seems as if the basic range checking has worked for generating one of the sub-cycles. Now I should get it working with one of the full cycles. Hmm...
	1. Re-write this so that the cycles are generated more cleanly using the reversing scheme and it's cleaner
	2. Incorporate the range aspect to make the generating usable exercises easier
	
So how do I approach this first one? It seems like it would be easiest to write a function which takes a stream and then generates another stream of the same elements but in reverse.
Hmm... Although strictly speaking it's not a complete reversal because of the starting and ending chords... hmm... i wish i had noticed this earlier... oh well... looks like I don't 
have to necessarily worry about this one...

So the question more so now is how do I handle the range aspect? It seems like it would be a good idea to specify default behavior where the range isn't taken into account. What range
would I specify there? And how would I do it with a set of strings? Hmm... Since we're dealing only with sets of three strings this should be pretty straight forward. Just make a
3-tuple with all the elements specified as the maximum range possible. Well since this is meant to be used with guitar/piano using the range of a grand piano as the default seems
like it would be a safe bet for now... hmm... or i could just make it an optional parameter and if it's not specified then the code doesn't execute... makes things a bit simplier
and more efficient...

Hmm... So it looks like I'm at the point where I can begin testing this... Hmm... so it definitely seems like the range checking feature is complete!

11/28/2020
So how does this range checking function work? It takes as parameters a chord as a list and a 3-tuple of note ranges. It then checks to see if each of the notes is within the specified
range and then transposes the entire chord up or down an octave accordingly. Hmm... I wonder if there's a better structure for handling the pitches in the music21 library somewhere.
That's a good question... Why did I not just use the chord object/class? I can revisit that at another point in time. So what do I need to do to test this? Generate some chords and
test them on a specified range set. Make sure that they test the various different cases:
	1. In Range - no transposition
	2. Out of range below - tranposed up an octave
	3. Out of range above - transposed down an octave
	
Ahh... So the function is working although it doesn't appear that way due to the music21 objects all being a reference (or what have you, I can't recall the exact/precise defintion here
I'll have to look that up another time). So it seems as if the basic range checking function works well... What was the test which triggered this? I needed to make sure that the range
functionality for the sub_cycle generation function works... Hmm.. There has to be some sort of larger testing strategy I could use here... I should probably research this some more 
to know the various types of testing I'll be doing...

Hmm... I wonder where this behavior is coming from in terms of constantly generating the different treble clefs. Is that something to do with the XML format or is it something from
Music21? The extra 7/4 time signature could be removed by merging both the cycles into one stream. This might actually be having much more of an impact than I anticipated. It would
probably be worth exploring that to see what happens... also, do I test the basic cycle functions at all? it would help me isolate this behavior... Hmm... Yes, it seems that a single
stream would handle things better since that is performing much better based on this full_cycle test. Hmm... How to handle this? Is there a function which already does this for me?
Perhaps the flatten function... Hmm... it would be nice to automate this formating but I'm not sure how to necessarily do that... Perhaps there's a way to write these streams directly
to a MusicXML format and from there something happens/works out...

Hmmm... I've asked a question on the forum so I should work on something else until I get a response or think of an idea

11/30/2020
Hmm... It seems as if learning how to do the page formatting the "proper" way involves a steep learning curve in terms of learning MusicXML as well as some of the deeper aspects of 
Music21. I can do everything else as much as possible and then come back to this. Hmm... It seems as if the text box needs very precise specifications regarding it's placement. This
is not what I'm looking for. I'd like it to be placed at the beginning of a measure. The lyrics tool might be more appropriate... Yes, I get a much closer representation to what I'm
looking for when using that. Then with each measure as a line itself things look better...

12/01/2020
Okay, so how do I do this? What am I attempting to do anyways? I would like to take a key and a voicing and generate all the possible chord scales for it on the various sets of strings.
I believe I have all the various functions in place for being able to achieve this. I think I would be able to do this with the "generate cycle pairs" function. This would allow me to
do a lot of these things. I would only need to call it for each of the various string sets. Hmm... It is unfortunate that I do not have a guitar here as it would be handy to realize/
test out the different chord voicings on... Hmm... There seem to be errors in some of my diagrams here... I'm not sure I had the best/most consistent naming scheme with the different
A/B forms... Hmm... yes... completing this for the drop 2 voicings is a bit different... There's are multiple different fingerings which are possible for the chords. Focus on getting
the closed triads done first and then work on the drop 2 triads with their multiple fingerings.

Okay... So how do we do this? It should be pretty straight forward. We know the key, we know the scale, hmm... we might have to transpose the starting chord to match the range (or 
modify the range checking algorithm to automatically bring the chord into range. From there we just pass it to the various functions and save and output the results. We'd also have to
make sure the naming is consistent/saved... Hmm... It might be a good idea to write a function in the GenerateChordScale module to automatically do the naming/saving for you/us...
Hmm... I need a way of associating a number with the different string sets as that would make things easier to name... I could sub-class the range class with a guitar string class
and then add a string number member to make this a bit easier... Well it would more be a separate... well maybe not... I could also make an enum... Hmm... it would also be nice if
I had a way of indexing the class itself... I can worry about the syntatic sugar later and just focus on getting the various conceptual aspects worked out... Hmm... so what is this
guitar range really? I mean it's a class which contains the ranges referring to the strings of a guitar. Given that this is fixed, operating on the indexing method might be a good way...
Hmm... However... Well what is it I want to do here? Being able to do things like slice and get multiple strings in one pass (i.e. 4-3-1 for a drop 2 voicing) would be extremely useful.
How is it I could achieve that? Well I could create a list dynamically once the function is called and put a dummy value in at the 0'th element. From there I could perform the operations
normally, making sure not to call anything with a 0. This works for now and I can rework it into something more elegant later... Hmm... Or I could subtract 1 from all the values passed
in the key and then use that to perform the operation...

Damn... I was thinking more how matlab vectors work... I'll have to take another stab as this tomorrow...

12/02/2020
Hmm... Adding this syntactic sugar is a bit more complicated than I thought. It's only six values so just hard code them...

Hmm... So what was I doing here again? I was attmpting to generate a chord scale exercise for each string set based on a certain key as well as a certain specified cycle. Hmm... Well
what do I do with the various cycles in between? Do I just export them to a file? That seems like a good method here... Hmm... This function will be different from the other ones. It
would write the files out within the function itself. Hmm... this could work... If we know the scale as well as the tonic we could generate a different starting chord for each different
string set. I think I'll also have to expand my range checking function to work on the drop 2 voicings...

Hmmm... The lowest note should be from the lowest string in the set. So we take that range and find the highest instance of the note in this scenario... I wonder if music21 has something
which does this? Hmm... How do we do this? There seem to be several ways. It definitely seems as if we need an octave number here to be as useful as possible. I could take the octave
number from the upper or lower range and then transpose as need be... That seems like a pretty good option... 

Hmm... I'm not entirely sold on the range aspects in terms of adding the extra notes. Chris Buono seemed to have a nice system in place where each chord only had one instance in the
range of frets he was working with. Hmm... That's an interesting way to think about it... It would be easier to test these ideas out ona guitar once I get back...

Although I would definitely say this first one was a success... However, the verification aspects of this look like they'll be a bit of a beast. So now I need to be able to do it for
all the different string sets. Interesting... 

Hmm... So it seems as if I have the basics down in terms of generating the chord scales on all the string sets for the close voiced chords. nice! What's next? I need to be able to do
this for the open voicings as well.

Ahh... I have figured out how to add the line breaks in musicxml! Now how do I make it so music21 can export these... Hmm... I believe I've figured it out... Well perhaps... I think
what I need to do is define explicit system breaks now...

12/04/2020
Hmm... So the stream class has a boolean which indicates whether or not all page breaks in the piece are explicitly defined. Hmm... Is this something I toggle or something which is
automatically generated? Evidently it mpas to the music xml <supports attribute "new-system"> tag... I should investigate this a bit more to fully understand it... It could hold the
answer I'm looking for... This also applies only if this is the outermost stream being shown. Hmm... Given that I'm only dealing with a single stream here... well actually I'm not
as I've got the measures which are streams themselves. But it is the outermost stream which is being shown... Hmm... well even though this doesn't explain things necessarily it does
indicate that it is possible to define these system breaks and put them in the stream somehow... I mean this is all fine and dandy but now we need to actually define some system
breaks. How to go about that? 

Well it looks like I need to look at this description much more closely.

There are two types of objects that speciy the layout on the page/screen for Scores and
other Stream objects. Hmm... Perhaps I could create a larger stream object to create
some sort of heiarchy which they already have code which generates things for...

There are two main types of layout objects. Layout objects describing elements and layout
objects describing streams. Hmm... Well what is the difference between the two?

ScoreLayout, PageLayout, SystemLayout and StaffLayout descibre the size of pages, the geometry
of page and system margins, the distance between staves, etc. Hmm...Well explicitly the
measures per line isn't mentioned here but it might fall under the "geometry of page"
and the etc part... The model for the layout objects is taken directly from MusicXML.
Hmm... I'm not entirely sure what this means and if there's a technical definition of
what "model" means here but this likely means studying the MusicXML documentation would
be useful.

So what is the second set of objects here? These are Stream subclasses that can be emplyoed
when a program needs to easily iterate around the systems and pages defined through the
layout objects just described. Hmm... So this wouldn't be what I need. I would more need
what I was previously talking about... Yeah, we just want to define the layout, not iterate
through it... Hmm.. Well perhaps... I'm not entirely sure how the layout aspect itself
works but supposing we create one we might need to iterate around it in some sort of a
fashion... Well shall see I suppose...

Hmm... Well now what do I do with this system object? Do I insert it or something?
Hot diggity damn, that seems to have done the trick!

Now I just have to decide where do I implement these formatting aspects? Is it something
I do in the generation of them? Hmm... That doesn't leave a lot of options if you don't 
like how things are formatted... I think it will be easier to apply the formatting at the
end as this leaves a lot more flexibility for what happens to the measures/systems in
between the various other parts of the chord...

Hmm.. Okay... So I'll need to iterate through the stream and then add a new system after
each of the measures. How do I go about that? Especially now that the stream is flat?
Hmm... What exactly does that mean...? Let's take a look at the object in memory?

Hmm... It potentially seems as if flattening the stream here wasn't the best approach.
It is now just a sequence of chords. Ideally having the individual measures retained
is what we want... Hmm... Although... Perhaps removing the 7/4 time signature object
from the second stream also helps accomplish what it is we're looking for here...

Hmm... but now I'm back to the issue with the various extra treble clefs...

Hmm... Interesting... It doesn't look like I properly apply the measure concept when
generating the cycles here. This might solve a few of the formatting issues and provide
a much better method for achieving what I want here... Having the granularity of defining
the various measures will help in achieving what I'm looking for...

It looks like I'd need to do that in the generate_full_cycle function... Hmmm... Although
the generate_sub_cycle function already has the measure functionality built into it...

Hmm... it might be useful to redefine this generate sub_cycle function to return the
next chord as well... This would help with the issue I had before I think... Hmm...
although some of the patterns didn't follow exactly the same format in terms of the
chord inversions which they started on... Hmm... I think I might have coded for that
in the data structures which contain the voice leading patterns...

