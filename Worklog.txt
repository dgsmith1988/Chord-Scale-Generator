08/28/2018
What to do regarding software for generating voice-leading patterns? Hmm... What is it I really want here...? I want to give the software a voicing and cycle pattern (i.e. 7/2, 4/5, or
3/6) and have it generate the corresponding chord progressions in all the keys. What about restricting things based on the layout of the guitar neck? Should I apply some sort of rules
based on which string set the exercise is to be done on? Hmm... It would be simple enough to generate the pattern and then transpose chords down or up an octave if they're out of range
of the strings in the set that has been selected. The ranges might move around a bit depending on the voicings selected... hmm... how do we cycle through the voicings? How is the next
note selected each time? Hmm... That will depend on which type of cycle you're using.

7/2 cycle - move all the notes
5/4 cycle - move two of the notes
6/3 cycle - move one of the notes

The exact details can be worked out more once you get a few examples on paper to work through...

How do I define the set of available notes to use so this can facilite using the melodic minor/harmonic minor scales (and any of the other modes potentially)? You could use an ordered
data structure. There might be something in music21 which already facillitates this.

Hmm... What was the logic behind the patterns Chris began with? Hmm... Well looking at the scores it looks like one way was descending of the two but the other was ascending in general

Cycle 2:Descending	-	Cycle 7:Acsending
Cycle 4:Ascending	-	Cycle 5:Descending
Cycle 3:Descending	-	Cycle 6:Ascending

Hmm... Why would the directions cycles switch based on the 4/5 pairing? Hmm... I'm not sure I understand the inital logic of the chord progressions themselves enough to see it right now.
Hmm... I think that's just a quirk of the relationship between chords a 4th apart... Especially if you hold common tones and move... But why...? What are the notes involved in terms
of scale degree functions...

I = 1 3 5
ii = 2 4 6
iii = 3 5 7
IV = 4 6 1
V = 5 7 2
vi = 6 1 3
vii = 7 2 4

1-w-2-w-3-h-4-w-5-w-6-w-7-h-8

Hmm... Yeah I don't think it has to do with the diatonic order directly... but just looking at the scale degrees involved in spelling the tones are very closely related... 1 chord one
is common and the other two are only a step away... I'll just leave that to be a quirk of the system for now as I've got other things to take care of... What was I doing again? Yes...
what are the rules which will govern how the different cycles operate in terms of note movement... Cycle 3/Cycle 6 seem easiest as only one note moves at a time... Hmm... I wonder if
there's some sort of chord comparsion function provided in the music21 library which would allow me to do that automatically...

Cycle 3 Pattern:	Bottom note moves down one scale degree (is that the right term? look this up later...)
					Middle note moves down one scale degree
					Top note moves down one scale degree
					This pattern looks like it repeats (I'm too lazy to check every single chord change...)
Cycle 6 Pattern:	Top note moves up one scale degree
					Middle note moves up one scale degree
					Bottom note moves up one scale degree
					There are no leaps beyond a step in any of the voice leading lines (beyond the tranposition when things go out of range)
Cycle 4 Pattern:	Bottom note is held, top and bottom voices move up one scale degree
					Middle note is held, top and bottom voices move up one scale degree
					Top note is held, middle and bottom voices move up one scale degree
Cycle 5 Pattern:	Top note is held, middle and bottom voices move down one scale degree
					Middle note is held, top and bottom voices move down one scale degree
					Bottom note is held, top and middle voices move down one scale degree
Cycle 2 Pattern:	Top and middle notes move down one scale degree, bottom note moves down two scale degrees
					Top and bottom voices move down one scale degree, middle voice moves down two scale degrees
					Middle and bottom note move down one scale degree, top voice moves down two scale degrees
Cycle 7 Pattern:	Middle and bottom voices move up one scale degree, top voice moves up two scale degrees
					Top and bottom voices move up one scale degree, middle voice moves up two scale degrees
					Top and middle voices move up one scale degree, bottom moves up two scale degrees
					
Hmm... I think I've got a good start here... It's time to get the code up and running to see what I can do and if I was right...

Hmm... Do I do this with chord or scale objects...? Let's take a look to see what the difference is... Hmm... It seems the best way to do this (at least following the method I have in
mind) is to use the scale object and use it to generate notes...??? Hmm... How do I do this? Extract a pitch each time? Have three separate objects? Have something keeping track of
each different voice...? Is there a method to take a pitch from a class and then have it remember it's part of a set of pitches from a scale? Hmm... IIRC the scale objects are formed
by a set of intervals or Interval Network.... Hmm... Was that a concrete or abstract scale? I would need a concrete scale as there would be a key... It appears as if the next() function
will allow me to do this...

Hmm... Would it be better to keep track of all the pitches in a chord object? Also will the pattern that the voices move stay the same depending on the voicing? I think not, the
relationships are more based on the tonal functions of the notes in each chord. How will I be able to do this more systematically and using music theory more than identifying patterns
... Although I'd bet the same patterns of note movement apply based on which part of the chord each note is (i.e. the 3rd always follows the same path but it changes by octave)...
I'll have to have some way of indicating which notes are moving each time and by how much... some sort of data structure which keeps track of the number of scale degrees to change
for each note...

Also, how do I store all the cycles and chords generated? hmm... it seems like this is something I could do easily with chords... although I could create a new chord with the new set
of pitches each time... hmm... But then if I modify the pitches would that modify the chord...? I can't remember exactly how music21 handles storing copies of things... I believe it
was a bit unorthodox and I'm not sure I fully understand their reasoning... I'll have to look into this...

Hmm... How is it that music21 stores it's stuff again...? everything is a stream? I'll need to make several measures (in 7/4) and then have those in a larger stream...

09/03/2018
What about 7ths and 6th chords? Adding another scale degree will add another voice to follow and (correspondingly have another path to deduce)... What about the harmonic minor/melodic
minor scales? Hmm... since we're dealing with tertiary harmony (although sus2 and sus4 chords will be slightly different...) and the harmonic movement is based on the relationships of
the scale degrees, as long as we have a data structure which keeps track of the scale degrees/note ordering properly (and keep it just to diatonic scales atm) then the actual scale
structure shouldn't be necessary to worry about... the system will take care of itself. I'll just have to work through one example with 7th chords in order to figure out the path for
each note (6ths can be added later as after learning 7ths it would proabably be easy to pick them out on the fly).

Hmm... What to do now... Is there any good software out there that could help me keep track of the tasks I have left to do? Well what is it that I have to do? Hmm... I still need to
explore the music21 library to figure out the best way to implement the ideas I have here... Hmm... it looks like creating a chord each time would be best... It doesn't look like 
there are any easy ways to quickly modify the notes of a chord...

12/12/2018
Hmm... It's been awhile but I think what is necessary is to create something which keeps track of an ordered set of pitches (i.e. a concrete scale object) and then have three different
"pitch pointers" so to speak... these data structures will represent the pitches as they move throughout the scale... I'm not sure how the exact details work but I have a good rough
idea... let's first try and create this and build from there...

what do i want in a pitch pointer? it keeps track of the index in the larger structure of what pitch to select... what if I go backwards? where do i start within the scale to make
sure I have enough room... hmm... what about using the scale.next() method...? is there a corresponding ".previous()" method? there is!!! praise jebus!!! I really need to experiment
more with using this and the scale object, also... what about what note do I start on? Ultimately this will be determined by the string set being used but for now I can just use
any starting pitch and then adjust this later...

ConcreteScale.next(pitchOrigin=None, direction='ascending', stepSize=1, getNeighbor=True)

That is the function we want...

12/13/2018
Hmmm... How do I store the information which dictates the way each note should move in a compact/easily accessible form? How will this be used? There will be an integer associated with
each chord tone that will be passed to the .next() function. When 4-note chords are added, this will have to be expanded slightly... For now don't worry about that and just focus on
getting the triads working correctly... What type of data structure would be best here? Hmm... This is really a choice based on my comfort/familiarity with Python... A 3x3 matrix would
probably do it...  3 entries in each row for each chord tone, and 3 columns as there are 3 steps until the pattern repeats...

Hmmm... Now I need a way of iterating over the larger structure... It seems splitting up the loops as I have done will create a lot of unecessary corner cases... I believe there is a
much cleaner solution to this problem... What do I want to do? It seems there's an issue since the number of transpositions necessary to complete a a cycle doesn't always correspond
with the number of chords per measure (i.e. 3 tranpositions v.s. 7 chords per measure)... how do I compactly represent this information in a loop?  I'll also have to change the 
measure which is being updated each time...

10/22/2020
Hmm... Okay.. What do do next... Well where was I with this project to begin with? Hmm... When I type show something pops up but it disappears quite quickly... Hmm... Perhaps it has to
do with my music21 configuration... Hmm... it might be worth updating my music21 libary to make sure I have the latest code... They seem to have added a lot of things which could be
useful... Hmm... So the music is displaying now, that is useful... Hmm... Okay... What is this and how is it useful? It looks like this is a cycle two ascending... Why is that? I mean
I shoudl go back through it and see what's up to make sure I'm identifying it correctly... Hmm... It looks like a cycle two but I'd have to learn the properties of a cycle two to be
more sure of what it is I'm looking at... Hmm... What was the goal here again? It has been awhile since I worked on this... Ahh... I want it to generate all the different progressions
in any key. Ahh... And then if memory serves correctly there are ways of linking the various cycles together... I can work on imposing the various restrictions regarding the string
changes after I get the basic stuff working... Hmm... What is it I want to do here? Hmm... Let's get a full cycle generated...

Hmm... this seems to have gotten more complicated... What I need to be able to do is figure out how to generate the next chord in the cycle and move it up and octave... Hmm... Yes...
My thinking just changed a bunch here... there's no point in doing it this way... I think what I could do is create functions to generate these various aspects... Hmm... Yeah, you could
pass it a starting chord and a cycle type and it would generate the corresponding cycle. This would be a lot easier and cleaner. From there if I wanted to generate the whole thing I'd
need to just do it by generating another progression but using the chord inversion i'm interested in to start with...

10/26/2020
So I'll work on developing the code to generate one complete cycle from a given chord... Hmm... Yes I reckon I definitely need to start on the tonic chord. That makes a lot of sense 
here... Hmm... what exactly does this matrix represent again? Got it... Hmm... so how do we generate the different notes here? Ahh... I need to manipulate the "pitch pointers" to generate
each of the different chords I'm looking for...  Hmm... I believe I could write these loops a lot cleaner based on the more powerful python iteration methods... So what is it I do now?
I use the cycle matrix to generate the different chords I'm looking for based on the starting_chord. So I take... Hmm... so I also need a way of making sure that the pitch order as
well as the element in each of the elements in the cycle matrix are changed... Hmm... Interesting... I believe there's a way to traverse both at the same time in Python... Hmm... I'm not
sure what's going on here... It might be worth creating a new data structure in here to copy the chord tones into... Hmm... That seems like it might do the trick... Hmm... is there a
way in music21 to convert a chord to a list of pitches?

Son of a bitch... it looks like there's another set of patterns for the different starting chords? or is there? I think i was able to generate a 21 chord sequence before... I'm not 
sure why I wouldn't be able to now...

10/28/2020
Hmm... okay... So these are all definitely permutations of the same matrix I believe... Hmm... so I believe this is correct... I'll need to test it out starting on the first inversion
chord... Hmm... I'm not sure if I'm liking this documentation here... There should be... Ehh... This works for now... Hmm... What is the next step? It would be nice to make sure this 
works in all keys. Hmm... I'd also need the functionality in place which makes it I can generate chord scales regardless of what 

Functionality Required:
 - Generate chord scales for arbitrary keys
 - Adjust chord scales to fit the ranges for particular sets of strings
 - Generate chord scales for major/harmonic/melodic keys
 - Geneate chord scales for the following cycles - done
	cycle 2
	cycle 7
	cycle 4
	cycle 5
	cycle 3
	cycle 6
 - Generate chord scales for arbitrary voicings (drop 2 and drop 3) - done
 - Generate chord scales for 7th chords
 
Hmm... So what should I do next? I'll clean this code up a bit... I should make sure I'm doing things as efficiently as possible... The first part would be to change these matricies
so they're just permutations of the first one... Hmm... I might even be able to generate the cycle 7 matricies as permuations of these... better not optimize too much at the moment...
Hmm... so i've got that part down... now let's focus on getting the other cycles in place... cycle 7 seems like the next best place to start

10/29/2020
Okay, lets work on getting the cycle 3 and cycle 6 chords generated... Hmm... A lot of this all depends on how you define what a cycle is. Is a cycle one smaller 7 chord sequence or
is this more something elaborate? Like we get all the way back to a root position triad for the starting point...? Hmm... Interesting question... I can contemplate that more later
after I figure out these basic cycle sequences... Hmm... Looks like I've got all the various cycles down... Lets take a look and refactor this into something we can use for the various
other parts. Hmm... How should this work? I could take all these various constituent functions and data structures and put them in a module. From there I can create a script which 
calls and uses the functions accordingly. That makes a lot of sense to me... Hmm... that's an interesting question... Will the cycle matrices stay the same for the harmonic and melodic
minor variants? I'm tempted to say yes as this is all based on tertian harmony and the movement of the various scale degrees. If those scales are harmonized in thirds and then the corresponding
notes are moved accordingly I think it would be similar... Hmm... It would be fairly simple to try, however I unfortunately don't have a set of written out examples to compare it to...
However I would be able to do this fairly easily from a music theory standpoint... Hmm... However... Before I get too far into it, it would be worth making sure that I'm doing things
correctly from the standpoint of music21 before I make this thing any larger... Hmm... It would also be useful to generate the full "21" chord cycles from one function call... Hmm...
These are good tasks to focus on while I'm building these things up...

10/30/2020
Okay... Let's work on developing these chord scales for different voicings... Lets tackle the drop 2 voicings first... Hmm... How do I do this? Might it be easier just to take one of
the pre-configured/generated scenarios and then just take one the middle note and move it down an octave? Hmm... How would I go about doing that? I would need to go through each measure
and each chord and get the middle note of each chord and move it down... Hmm... Or I could attempt to use a different starting pitch and then change the different cycle matricies around...
I mean both options seem equally valid... Although it might be easier to try and move the matricies around first... Hmm... I think it would work... I would just have to match things 
so the rows would correspond to the same starting scale degree... Would that necessarily be easier than just going through all the chords in a sequence and moving a voice down an octave?
I think not... Hmm... Especially as we could make a function to do that and then pass a parameter to determine what note is transposed down an octave... That honestly seems like a much
better approach to this... Although it would be worth cleaning things up and encapsulating some of the functionality here a bit better... hmm... how do I do this? have several calls 
to generate_cycle I would reckon... 

Hmmm... So what is meant by a full cycle here? This would be a complete cycle of 21 chords without any sort of tranposition between the chords. Hmm, it's probably better to pass a string
which indicates the cycle type... Hmm... This is a bit messy as some of the patterns deviate a bit... hmm... I still need to make the cycle 6 chords however... Hmm... However there 
are the two different ideas here of a cycle. Like you can have a full cycle for cycle 2 developed and then there's a cycle 7 which comes afterwards to make a whole complete exercise
in both directions... That would be interesting... so what do I call these two ideas? There are "full cycles" as well as "full exercises"? Hmm... I'm not sure if that's the best name
for these things but it's definitely a start... Hmm... is there some sort of a programming construct which could be applied here? It seems a bit redundant to go ahead and complete a
bunch of other if statements again... although that's all I have in mind at the moment... well this is a first draft so it's likely to be changed a whole bunch in order to figure things
out... hmm... what is it i'm trying to do here? I want to be able to select which matrix is passed each time... hmm... another layer of indirection might help here but i'm not sure
how useful it would be... unfortuantely it's not as simple as selecting just one variable type... Hmm... however... I could make a multidimensional list... I mean I've already created
a multidimensional list but this would be a three dimensional list... Hmm... although if all the permuations as based on one matrix and they're the same for the two large classes of 
cycles then I'd be able to use that information to generate what i need...

10/31/2020
Hmm... So how do I create a three dimensonial list here? Hmmm... how do I construct this? Do I create an empty list or is this something which can be dynamically generated? Hmm...
Interesting question... Hmm... so it looks like I've figured out how to organize these... I'll do them in isolation and then integrate everything into the main code base... Hmm... 
What would be the advantage to using numpy arrays here? Well it might be easier to encode these matricies using actual matricies... Plus it would be easier to perform all these different
operations on each matrix based operations I reckon... Hmmm... I should just open it up and try and do that... 

Hmm... Yes, I'm liking numpy quite a bit more here for the arrays. However, hmm... how do I do this? Do I define all the cycle 7 matrixes based on what the initial cycle 2 ones were
or do I do it based on the initial cycle 7 matrix? Hmm... I mean this one is definied by the cycle 2 in it's own way. Roughly speaking what you have is several different permutations
of the same rows. Hmm... I could see it being done either way... Although it might be nice to have the cycle 7 one listed out explicitly... However if there are any changes to the 
cycle 2 matrix then it would be nice to have these propagate throughout the rest of the system... But the odds of it changing are relatively small to begin with... I mean it would be
interesting to note the relationship exactly between the cycle 2 and cycle 7 matricies however it seems like it's something that can be explore much later on...

Hmm... Okay... Now that I have these new data structures representing the matricies I need to figure out how to integrate them into the rest of the system...

Hmm... What to do for this next? I need to figure out how to iterate through these data structures so I can incorporate them into the rest of the program I wrote... Hmm... I think I
might be able to use the exact same program... I'm not sure how many modifications are needed... Hmm... it seems as if they fit quite nicely... 

So how do we do this full cycle thing? Is there a way to check which data structure was passed? Hmm... Well there is a nice comparison function for the whole array... how are these
results then interpreted?

11/01/2020
Hmm... Okay, what's the next step? Well let's straighten out the full_cycle generation function so that it starts at one octave and then doesn't need to be adjusted at all... It should
be one continuous cycle that is then adapted/adjusted based on the range needs of whatever instrument is it being played on (or whatever the constraints that need to be added are).
Hmm... I'm not entirely sure how this inversion function works... I should look into this... Hmm... The inversions seem to be done based on moving the notes up an octave. Hmm... I 
mean that makes sense to an extent as that's how things are traditionally taught... However it would be a nice feature if you could say which way you want to achieve the inverison...
By that I mean which direction you want the notes to go. It doesn't seem to try and find the easiest path in terms of inversion generation... Although this doesn't really explain
why I'm getting massive octave jumps here... I'll have to use a breakpoint to figure it out... ahh, I see why these inversions are being created like this... Hmm... Perhaps generating
the sub-cycles isn't the best approach here... It might be to iteratively apply the cycle matrix, or it might be easier to pass deep copies so this situation doesn't arrive... Hmm...
how do I do this in a way though where I don't modify the originally passed chord? Hmm... Although that's an intersting question... Is that what I want? I mean it would be nice to do
that and have it so there's no modification to the passed chord... Although... Hmm... I wonder why they do things in this manner? I can see how it might be better to be able to make
an adjustment to one object and since everything is a reference then everything else would adjust accordingly... That might make it a bit tricky in larger programming contexts however...
Hmm... yes... it appears the deep copy method worked... What to do next? I would like to be able to generate the ascending and descending pairs like in the Chris Buono exercises...

So this would be a function which generates an ascending cycle followed by a descending cycle. the three different types are:
 - cycle 2/7
 - cycle 4/5
 - cycle 3/6
 
Hmm... this is where the Buono examples break down as they were designed to be played all over the guitar neck... Hmm... the nature of the cycles will become more evident as I generate
these different exercises but for the 3/6 ones it looks like you start at one octave and then end on another... it would be worth exploring the other cycle pairings hmm... this is what
i thought might happen... i need to figure out how to append these various cycles together on a measure basis... hmm... I would need to learn the various heirarchies of the stream,
measure, part and all that in order to figure out how these things work... Hmm... it might be better to change the other storage types to streams... or perhaps a list of measures...
I'm not entirely sure... That would be something which would be interesting and worth investigating...

11/02/2020
Hmm... I need to be able to indicate that these are measures of 7/4. How do I do that? That would likely be in the subcycle function... Hmm... It might be good to develop a test module...
Essentially just a collection of tests on the various pieces of functionality here... Hmm... Theoretically I should just be able to iteratively apply these matricies... That would make
things a whole lot easier for being able to generate one particular "full cycle" meaning a 21 chord sequence which follows the same progressions... Hmm... do these patterns which I noted
before apply every time? I think so... In fact it would be easier to do it without having to deal with the inversions as it will make the code more consistent across different voicings...
Hmm... Although here it would be useful to operate on the chord which has been passed so after the cycle has been done in one direction then you just take that same chord and feed it
as the starting parameter to the next one... hmm... Yeah, I'm fairly certain that will work...

Hmm... This is an interesting puzzle, the tricky part will be figuring out how to translate this into a loop...
Hmm... If I append a time signature of 7/4 to the stream, will everything take care of itself basically?

Hmm... I think the best way to do this would be to create a larger loop which handles the total number of chords for the iteration and then... hmm... so 0-20 will be 21 iterations...
we want 20 so I should go 0 to 19... I was wrong there... 0 to 20 is what we want as the end isn't included

Hmm... What about the ending chord? How do we want to do this? I'm not sure if the chord itself is used/modified... it most definitely is not as we first turn it into a list of pitches
and then begin modifying it... hmmm... how ever it each of those pitches are referenced in the original chord structure then what's up with that...? Hmm... well what we do is completely
change the chords in the list...

Hmm... I'm not sure what to do for now... I can always go back and change things... it would also definitely be super useful to encapsulate this "row" functionality... in terms of 
applying a row to a chord as a list... Hmm... I wonder why the extra treble clefs are being added... Hmm... this is a fairly small issue and can be dealt with later... the core of
the functionality is there that i need and i can develop all the rest of what i'm working on here...

11/04/2020
Hmm... It definitely seems like the basic cycle pairs have come out correctly. Okay.. What's the next step? I think the next step would be to generate these for different chord voicings.
Hmm... How would that necessarily differ? I mean the same relationships in terms of the movement of each voice would be the same I think. What is iddferent is identifying the starting
note of each "row". Or each chord perhaps is a better way to put it... Let's write one out to make sure you see how it works... Hmm... What does this effectively change to? Ahh... In 
terms of the matrix operations this can be acheived by swapping columns. And this makes sense as each column represents the relative position vertically of each note. Each row represents
the motion of the tone in each transition. Hmm... How would I acheive this more easily? Also, what about the drop 2 and drop 3 voicings. Hmm... I don't see any harm in necessarily 
creating drop 3 triads... Hmm... Although forming the various inverions here would be difficult. Hmm... That might be why they're not used as much... Or it might be why they're not
labeled in the same way. If I did this, all I would get is the same thing but with a note an octave down. Hmm... Although it makes sense in a certain way. You don't use the same rules
as for the closed voicings since you have compound intervals. However if you have a "seed triad" and then generate the voicings from them by moving each note to the next chord tone 
ascendingly then you can generate the voicings in a similar manner. Hmm... Interesting... Especially interesting as since the chord tones appear in the same order, just with an octave
in between them, theoretically I could use the same cycle matrix to generate them. Hmm... yes, I see why this wouldn't work. It might be necessary to generate them intervallically.
Hmm... Although where do you stop... I mean you could also generate voicings by adding another octave between any of the notes... Hmmm... I mean theoretically you would have a "raise
1" if you went the other route and had the octave added to the G. Hmm... I mean it's not as if these voicings aren't necessarily useful... However... Hmm... Yes, these are interesting...
exercises... I especially like how they sound on my acoustic... However unfortunately it seems as if my acoustic needs a bit of work... Hmm... So this seems to have worked... Interesting...
I wonder if the same rules regarding the inversions for reversing the cycles applies. This is quite possible. If so I would be able to darastically change some of the functions and make
things a whole lot more efficient... Hmm... Man, I could save a lot of time here by just applying the column swapping matricies based on the permulations of the identity matrix. Although
I would need to tranpose it first as the permutation matricies only apply to row operations it seems. How do these apply to three dimensional matricies? Hmm... It doesn't seem like
that is necessary really... I can just change the order of matrix multiplication in order to achieve this.

11/08/2020
Okay... So how to modify the code to generate the various other parts... By that I mean how do I modify the code in order to make it so I can generate the cycle pairs using the swapped
matricies more easily? Hmm... Adding a flag to trigger the drop 2 aspect would be a good way. Hmm... Why is this Ab showing up as as G#? That shouldn't be... Is this a music21 problem
or a MuseScore problem? Hmm... This seems to be a bug within the music21 library itself... Calling transpose(0) turns the Ab into a G#. This should not be... Deep copy seems to be a 
better way of handling this... Hmm... I mean strictly speaking this did give me the melodic minor harmonization in a way (there is different behavior when the scale is ascending compared
to when it is descending). I wonder why this didn't occur with the harmonic minor scale... That's a good question... 

11/09/2020
Hmm... Is there a way to create your own scales here? That would be nice as I could theoretically create a melodic minor style scale to be able to acheive what it is I want to do here.
Hmm... I mean theoretically I could make a function to reverse a sequence. Hmm... I mean that would be fairly useful as I could re-write this function to be even more generalized and
it wouldn't require have a type specified. Hmm... Although I would still have the issue of generating arbitary chord scales, hmm... it seems as if 

11/14/2020
Hmm... What to do here? I should get the melodic minor scale working. It would really be ncie to have everything conform to the same interface so it makes it easier to work with everything.
Hmm... Okay... I think there's a way to create a scale which operates in a similar fashion to what I'm looking for... Hmm... What to do here? It might be easier just to use a basic
scale and let the user define it to whatever they want it to be. This would make things easier since you could define whatever arbitrary scale you want to use. Some of these matricies
would only be so useful since since they apply to your basic diatonic scales. But that makes sense to develop those ideas first. Hmm... I believe I have the basics working here... I mean
to truly understand the various differences between the different scale harmonizations would require a lot more studying of them. Hmm... But I believe I have the basics of the arbitary
scale as well as the harmonic minor scale at the moment... That's good! Ultimately the more I use the tool and test it, the more the different bugs and kinks will get worked out...

Hmm... How would I generate chord scales for arbitary voicings? That's a good question... I mean I'd need to rewrite some of the cycle matrices in order to achieve this. That's another
task in and of itself. I'd say I have a fairly good idea of how to do this. Hmm... Yeah... It's probably better to generate these different matricies based on modifying the current ones.
Hmm... Makes sense. I could write out the matricies for 7th chords and then modify them to generate chord scales with 6ths. I could also write out the matricies for 7th notes and then
pass in a smaller matrix from this for the triads. Hmm... I'm not sure what the best approach is at the moment. But it looks like I have a clear idea of what would be next. Those two
features are roughly orthogonal I reckon. 

Hmm... I'm not sure how to approach this range issue. I mean each note would have to appear on a different string. I could define some sort of
a string object or something and once the range is violated on any one of the strings by any one of the notes then we transpose it up or down an octave depending on what's going on.
That seems to be a fairly straight forward way of approaching the range issue.

Hmm... What about this 7th chord issue? I mean this opens up a lot more different possibilties for the various types of drop chords. I mean I think the best thing to do here would be
to write out an example of the progression to see exactly how many entries in the matrix would be necessary. You have to include motion for an extra note. Is there a forth row then as
well or just a 4th column? I think there might be a fourth row as things would expand a bit and there's an extra inversion... I suppose there's only one way to find out... Hmm... What
were the tricks which Chris Buono was using to generate the triad chord scales? I guess I'd have to go back and watch the videos.... Hmmm... It seems as if this Ed McGuire book has them
written out... This is probably something worth looking at much more closely. It definitely seems a lot mroe complicated than I was originally thinking... I think the range issue would
be the next thing to tackle. Afterwards, I can revisit these different chord scale ideas to try and figure out the best way to generate different voice leading patterns for them.

11/20/2020
Okay, so lets try and figure out how to approach the range issues and make it eaiser to play the patterns on a set of strings which are inherently finite. Hmm... So how would we do this?
Should we generate the cycle and then go through it chord by chord to transpose them all as need be? Hmm... what about checking the range of the chords while the cycle itself is 
actually being generated? That would be an interesting approach and probably a lot more efficient in certain regards. After we transpose it up/down an octave we could then pass the new
chord to the next part of the algorithm so it could continue on its merry way as it operates on a per chord basis. Hmmm... Yeah, that makes a lot more sense to me at this point. If I
consider the other option then it would be hard to figure out when we need to stop transposing. Or would it? I reckon it would be comparatively althgouh I'd need to write out an example
and compare the two approaches to be able to say for sure... it seems like right after apply_row_to_chord() would be the best place to add the range checking it might get tricky adding
the range checking feature to the sub_cycle generator as well. But let's keep working and see what happens...

Hmm... So how do we represent this concept of range here? It would likely involve two pitch objects, one for the start and one for the end of the range. How do we do this for the different
strings? Well each string will have it's own range. We will just need to figure out how to assign a string to each of the different voices of the chord. Hmm... Makes sense... Do we add
the open strings? Hmm... I mean it might be an iteresting way to approach studying these. I can say I really see a point in not including them (beyond just adhering to a particular rule).
It would make an interesting exercise to properly mute things and make sure you play the voicings correctly... That's just an arbitrary configuring of the range parameter however. Hmm...
That should be fairly easy to fix. Hmm... However how does this algorithm work? So we look at each note and see if it is out of range for the string it should be on. Once we've done that
then we determine whether or not to transpose it up or down an octave. Hmm... Yeah, I can see how this works... 

So how do we create a range here? And then how do we create a model of the guitar's range... Each string effectively has it's own range. These would then be used to figure things out.
Hmm... we need some sort of a pitch comparison function here... I wonder if music21 has anything for that... Looks like they do... And they even have something which includes doing
the comparisons for enharmonic notes. This would definitely be useful for our purposes... it looks like that's exactly what I'm looking for... the .ps attribute returns a float corresponding
to some sort of pitch space concept... So how do I do this and what is meaningful for our purposes here? and what do we want to return from the comparison function? we should have three
return values, in range, above range and below range. An enum would be nice here... Can I nest this inside the range class? Looks like I can... So how does this work? Pretty straight 
foward...

Hmm... okay... What to do next? Now that I have a range class I need to implement one for each string. Another class would be useful here for representing/storing the range of the guitar.
Theoretically this could be expanded quite a bit for ust about any other instrument... Now how do I do this. Hmm... It might also be easier to use a list here in terms of the ordering.
Then the numerical string value sets could more easily be computed/matched with the data structure... I can work on this tomorrow... It's getting close to bed time now...

11/21/2020
Okay... So let's take another look at this. Hmm... so how do I check to see if the chord is within the specified range? we'd have to have an ordered/corresponding pair of ranges to
match the order of the notes in the chord. hmm... i mean there are likely several different ways to go about this... 

11/23/2020
Hmm... I think the best way would be to solve this for a few of the most common cases and then try to generalize it from there... Let's do this for the 1-2-3 string set. Hmm... given 
that we're working with three note objects here then something like a 3 note tuple would be nice. Seems like a three element tuple would be what I'm looking for here... is it worth
enumerating all the various different string sets? possibly... so how do we check the range of each note? 

well we do have the chord as a list... ahh we could also use one of those things where we traverse multiple iterables at once... hmmm.... so what do I do now? I need to look at the 
return value and figure out what to do with it... hmmm... is there a possibility that after the transposition things won't work? well why would that work? that would mean that... hmm...
so there are three notes. well they would have to be some pretty strange voicings for that to occur. that shouldn't be happening with any of the voicings i've selected. I'm not quite
up to the task of figuring all that stuff out atm... 

hmm... that's a very good point to note here... should i be using the guitar pitches as they are written or as they actually are? becasue as they're written they're transposed up an
octave. hmm... given that i'm mainly using them to display things i don't think it matters if the notated pitch is different than the actual pitch...

11/24/2020
Hmm... So it seems as if the basic range checking has worked for generating one of the sub-cycles. Now I should get it working with one of the full cycles. Hmm...
	1. Re-write this so that the cycles are generated more cleanly using the reversing scheme and it's cleaner
	2. Incorporate the range aspect to make the generating usable exercises easier
	
So how do I approach this first one? It seems like it would be easiest to write a function which takes a stream and then generates another stream of the same elements but in reverse.
Hmm... Although strictly speaking it's not a complete reversal because of the starting and ending chords... hmm... i wish i had noticed this earlier... oh well... looks like I don't 
have to necessarily worry about this one...

So the question more so now is how do I handle the range aspect? It seems like it would be a good idea to specify default behavior where the range isn't taken into account. What range
would I specify there? And how would I do it with a set of strings? Hmm... Since we're dealing only with sets of three strings this should be pretty straight forward. Just make a
3-tuple with all the elements specified as the maximum range possible. Well since this is meant to be used with guitar/piano using the range of a grand piano as the default seems
like it would be a safe bet for now... hmm... or i could just make it an optional parameter and if it's not specified then the code doesn't execute... makes things a bit simplier
and more efficient...

Hmm... So it looks like I'm at the point where I can begin testing this... Hmm... so it definitely seems like the range checking feature is complete!

11/28/2020
So how does this range checking function work? It takes as parameters a chord as a list and a 3-tuple of note ranges. It then checks to see if each of the notes is within the specified
range and then transposes the entire chord up or down an octave accordingly. Hmm... I wonder if there's a better structure for handling the pitches in the music21 library somewhere.
That's a good question... Why did I not just use the chord object/class? I can revisit that at another point in time. So what do I need to do to test this? Generate some chords and
test them on a specified range set. Make sure that they test the various different cases:
	1. In Range - no transposition
	2. Out of range below - tranposed up an octave
	3. Out of range above - transposed down an octave
	
Ahh... So the function is working although it doesn't appear that way due to the music21 objects all being a reference (or what have you, I can't recall the exact/precise defintion here
I'll have to look that up another time). So it seems as if the basic range checking function works well... What was the test which triggered this? I needed to make sure that the range
functionality for the sub_cycle generation function works... Hmm.. There has to be some sort of larger testing strategy I could use here... I should probably research this some more 
to know the various types of testing I'll be doing...

Hmm... I wonder where this behavior is coming from in terms of constantly generating the different treble clefs. Is that something to do with the XML format or is it something from
Music21? The extra 7/4 time signature could be removed by merging both the cycles into one stream. This might actually be having much more of an impact than I anticipated. It would
probably be worth exploring that to see what happens... also, do I test the basic cycle functions at all? it would help me isolate this behavior... Hmm... Yes, it seems that a single
stream would handle things better since that is performing much better based on this full_cycle test. Hmm... How to handle this? Is there a function which already does this for me?
Perhaps the flatten function... Hmm... it would be nice to automate this formating but I'm not sure how to necessarily do that... Perhaps there's a way to write these streams directly
to a MusicXML format and from there something happens/works out...

Hmmm... I've asked a question on the forum so I should work on something else until I get a response or think of an idea

11/30/2020
Hmm... It seems as if learning how to do the page formatting the "proper" way involves a steep learning curve in terms of learning MusicXML as well as some of the deeper aspects of 
Music21. I can do everything else as much as possible and then come back to this. Hmm... It seems as if the text box needs very precise specifications regarding it's placement. This
is not what I'm looking for. I'd like it to be placed at the beginning of a measure. The lyrics tool might be more appropriate... Yes, I get a much closer representation to what I'm
looking for when using that. Then with each measure as a line itself things look better...

12/01/2020
Okay, so how do I do this? What am I attempting to do anyways? I would like to take a key and a voicing and generate all the possible chord scales for it on the various sets of strings.
I believe I have all the various functions in place for being able to achieve this. I think I would be able to do this with the "generate cycle pairs" function. This would allow me to
do a lot of these things. I would only need to call it for each of the various string sets. Hmm... It is unfortunate that I do not have a guitar here as it would be handy to realize/
test out the different chord voicings on... Hmm... There seem to be errors in some of my diagrams here... I'm not sure I had the best/most consistent naming scheme with the different
A/B forms... Hmm... yes... completing this for the drop 2 voicings is a bit different... There's are multiple different fingerings which are possible for the chords. Focus on getting
the closed triads done first and then work on the drop 2 triads with their multiple fingerings.

Okay... So how do we do this? It should be pretty straight forward. We know the key, we know the scale, hmm... we might have to transpose the starting chord to match the range (or 
modify the range checking algorithm to automatically bring the chord into range. From there we just pass it to the various functions and save and output the results. We'd also have to
make sure the naming is consistent/saved... Hmm... It might be a good idea to write a function in the GenerateChordScale module to automatically do the naming/saving for you/us...
Hmm... I need a way of associating a number with the different string sets as that would make things easier to name... I could sub-class the range class with a guitar string class
and then add a string number member to make this a bit easier... Well it would more be a separate... well maybe not... I could also make an enum... Hmm... it would also be nice if
I had a way of indexing the class itself... I can worry about the syntatic sugar later and just focus on getting the various conceptual aspects worked out... Hmm... so what is this
guitar range really? I mean it's a class which contains the ranges referring to the strings of a guitar. Given that this is fixed, operating on the indexing method might be a good way...
Hmm... However... Well what is it I want to do here? Being able to do things like slice and get multiple strings in one pass (i.e. 4-3-1 for a drop 2 voicing) would be extremely useful.
How is it I could achieve that? Well I could create a list dynamically once the function is called and put a dummy value in at the 0'th element. From there I could perform the operations
normally, making sure not to call anything with a 0. This works for now and I can rework it into something more elegant later... Hmm... Or I could subtract 1 from all the values passed
in the key and then use that to perform the operation...

Damn... I was thinking more how matlab vectors work... I'll have to take another stab as this tomorrow...

12/02/2020
Hmm... Adding this syntactic sugar is a bit more complicated than I thought. It's only six values so just hard code them...

Hmm... So what was I doing here again? I was attmpting to generate a chord scale exercise for each string set based on a certain key as well as a certain specified cycle. Hmm... Well
what do I do with the various cycles in between? Do I just export them to a file? That seems like a good method here... Hmm... This function will be different from the other ones. It
would write the files out within the function itself. Hmm... this could work... If we know the scale as well as the tonic we could generate a different starting chord for each different
string set. I think I'll also have to expand my range checking function to work on the drop 2 voicings...

Hmmm... The lowest note should be from the lowest string in the set. So we take that range and find the highest instance of the note in this scenario... I wonder if music21 has something
which does this? Hmm... How do we do this? There seem to be several ways. It definitely seems as if we need an octave number here to be as useful as possible. I could take the octave
number from the upper or lower range and then transpose as need be... That seems like a pretty good option... 

Hmm... I'm not entirely sold on the range aspects in terms of adding the extra notes. Chris Buono seemed to have a nice system in place where each chord only had one instance in the
range of frets he was working with. Hmm... That's an interesting way to think about it... It would be easier to test these ideas out ona guitar once I get back...

Although I would definitely say this first one was a success... However, the verification aspects of this look like they'll be a bit of a beast. So now I need to be able to do it for
all the different string sets. Interesting... 

Hmm... So it seems as if I have the basics down in terms of generating the chord scales on all the string sets for the close voiced chords. nice! What's next? I need to be able to do
this for the open voicings as well.

Ahh... I have figured out how to add the line breaks in musicxml! Now how do I make it so music21 can export these... Hmm... I believe I've figured it out... Well perhaps... I think
what I need to do is define explicit system breaks now...

12/04/2020
Hmm... So the stream class has a boolean which indicates whether or not all page breaks in the piece are explicitly defined. Hmm... Is this something I toggle or something which is
automatically generated? Evidently it mpas to the music xml <supports attribute "new-system"> tag... I should investigate this a bit more to fully understand it... It could hold the
answer I'm looking for... This also applies only if this is the outermost stream being shown. Hmm... Given that I'm only dealing with a single stream here... well actually I'm not
as I've got the measures which are streams themselves. But it is the outermost stream which is being shown... Hmm... well even though this doesn't explain things necessarily it does
indicate that it is possible to define these system breaks and put them in the stream somehow... I mean this is all fine and dandy but now we need to actually define some system
breaks. How to go about that? 

Well it looks like I need to look at this description much more closely.

There are two types of objects that speciy the layout on the page/screen for Scores and
other Stream objects. Hmm... Perhaps I could create a larger stream object to create
some sort of heiarchy which they already have code which generates things for...

There are two main types of layout objects. Layout objects describing elements and layout
objects describing streams. Hmm... Well what is the difference between the two?

ScoreLayout, PageLayout, SystemLayout and StaffLayout descibre the size of pages, the geometry
of page and system margins, the distance between staves, etc. Hmm...Well explicitly the
measures per line isn't mentioned here but it might fall under the "geometry of page"
and the etc part... The model for the layout objects is taken directly from MusicXML.
Hmm... I'm not entirely sure what this means and if there's a technical definition of
what "model" means here but this likely means studying the MusicXML documentation would
be useful.

So what is the second set of objects here? These are Stream subclasses that can be emplyoed
when a program needs to easily iterate around the systems and pages defined through the
layout objects just described. Hmm... So this wouldn't be what I need. I would more need
what I was previously talking about... Yeah, we just want to define the layout, not iterate
through it... Hmm.. Well perhaps... I'm not entirely sure how the layout aspect itself
works but supposing we create one we might need to iterate around it in some sort of a
fashion... Well shall see I suppose...

Hmm... Well now what do I do with this system object? Do I insert it or something?
Hot diggity damn, that seems to have done the trick!

Now I just have to decide where do I implement these formatting aspects? Is it something
I do in the generation of them? Hmm... That doesn't leave a lot of options if you don't 
like how things are formatted... I think it will be easier to apply the formatting at the
end as this leaves a lot more flexibility for what happens to the measures/systems in
between the various other parts of the chord...

Hmm.. Okay... So I'll need to iterate through the stream and then add a new system after
each of the measures. How do I go about that? Especially now that the stream is flat?
Hmm... What exactly does that mean...? Let's take a look at the object in memory?

Hmm... It potentially seems as if flattening the stream here wasn't the best approach.
It is now just a sequence of chords. Ideally having the individual measures retained
is what we want... Hmm... Although... Perhaps removing the 7/4 time signature object
from the second stream also helps accomplish what it is we're looking for here...

Hmm... but now I'm back to the issue with the various extra treble clefs...

Hmm... Interesting... It doesn't look like I properly apply the measure concept when
generating the cycles here. This might solve a few of the formatting issues and provide
a much better method for achieving what I want here... Having the granularity of defining
the various measures will help in achieving what I'm looking for...

It looks like I'd need to do that in the generate_full_cycle function... Hmmm... Although
the generate_sub_cycle function already has the measure functionality built into it...

Hmm... it might be useful to redefine this generate sub_cycle function to return the
next chord as well... This would help with the issue I had before I think... Hmm...
although some of the patterns didn't follow exactly the same format in terms of the
chord inversions which they started on... Hmm... I think I might have coded for that
in the data structures which contain the voice leading patterns... I'll have to look
into this later...

Hmm... it might not even be necessary as the same voiceleading pattern seems to apply
throughout. If memory serves correctly I wrote those to have it so depending on the
chord inversion you started with, you would have all the options you needed...

Hmm... I believe I got it...

Hmm... so what do we do now? We generate the various three sub_cycles. Hmm... Although
something might come up with the matrix pages but we can deal with that later...

Hmm... so what do I do here? I need to generate three sub-cycles to create a fully
cycle. How do I do this? Generate one and then use the chord which is returned by the
cycle as the seed for the next sub_cycle...

Hmm... So what I need to do here is change the order in which tranposition matricies
occur...

Hmm... this is bizarre... It seems some sort of unexpected behavior occurs when the
measure is added to the stream and the time signautre is already there... I wonder
what's going on... I'll need to check the append() function...

Hmm... So I definitely got the functionality I was interested in working... Now to save
my place and then replace the old code with this new functionality. I'll also have to
re-order some of the matricies in order to make sure the transitions occur properly...

Hmm... or perhaps only the first measure in each stream needs to have the time signature
object embedded in it... let's try that...

Ahaha! I got it!

And the various cycles seem to be working nicely! Now to make it so there's one measure
on every line.

Hmmm... It would be interesting to explore this voice concept more as a potential way
for organizaing and manipulating the music...

Hmm... So I've figured out how to add a line break after every measure... Now I need how to 
determine how to strech the last measure so it fits the entire last line... I could
just add an empty measure... Although that wouldn't be as clean... Or one last measure
where I end on the beginning chord...

Hmm... perhaps I don't need to necessarily export them to PDF. The MusicXML files are handy
and anyone could do whatever they want with them. Hmm... Plus being able to hear a bit 
of playback could help with practicing. Although the PDF would be nice for a cleaner
view of the material while practicing. Hmm... Yeah, let's just keep it to MusicXML format
files for the time being...

12/06/2020
So now I need to figure out how to handle the drop 2 voicings. Hmm... Let's see here... I mean I would need to decide on which of the fingerings to use... But having a clear starting
point would be nice. A good departure point would be to start with one voicing, that one being something like 6-5-3 and then branching out from there. Hmm... changing the voicing used
would just be changing the permutations of the strings used to generate the different range checks. That's really not too bad. Hmm... I mean I could theoretically use any sort of 
string set and the algorithm would figure out how to change the notes and everything to make it all work. Hmm... Yeah, figuring out the different other forms would mainly just be
figuring out how to generate the permuatations successfully. Hmm... It's really like before the rest of the code I need a way to determine what permutations of the strings to use.
This will ultimately be decided by the voicing passed... This parameter would mainly change how the loops are configured... 

So let's iterate them out...

For the Drop 2 - A Form we get
6-5-3
5-4-2
4-3-1

So that's 3 sets of three strings. Hmm... I wonder if there's a way to more precisely determine these things mathematically to know for sure that I have established all the different
possible permutations. Hmm... that would be an interesting thing to look into at another point...

For the Drop 2 - B Form we get
6-4-3
5-3-2
4-2-1

Hmm... So that's only 3 forms there...

What about the closed triads?
6-5-4
5-4-3
4-3-2
3-2-1

That's four different sets of three strings each. Hmm... that's not too bad. I mean now we just need a way of programmatically generating the 

So I need a way of programmatically generating the three permutations from a parameter... Hmmm... We could try and programmatically generate all the different possibilities but it
might be easier to hard code them. Or if there was a way to pass a function which generates the different formulas to determine the string indicies that would be cool as well. I mean
you can pass functions in other languages so I don't see why you couldn't do something similar here either... Hmm... it seems like I would have to write more functions than it's worth...
I'm sure there's some sort of a coding technique which could be used here to facilitate things better.

Hmm... so I need to modify the code to turn the matricies into drop 2 matricies. I have code which does this for a matrix page. I could do this for each page in the matrix or I could
write a function to do it to the entire matrix... it might be easier to use the pre-existing function to do this to for each page in a matrix... that sounds like a good plan...

Hmm... I'm not seeing any sort of transposition or anything within these functions based on the ranges specified by the strings... Hmm... it really seems as if something is wrong with
the range checking and transposition functions... hmm... I'm not sure if I had anticipated how the drop 2 triads would work here... ahh... That's one of the issues here as well... I
don't necessarily start out with a chord in a drop 2 inversion... Hmm... getting closer... Hmm... Given that the other chord progressions are generated correctly, this definitely points
to the range_checking_function as being the issue... hmm... this is bizarre... it seems to recover eventually as well... might be some sort of a memory reference/pointer issue? not
sure...

12/23/2020
Hmm... This is quite strange. The chord recovers and this makes no sense based on my current comprehension of things. Hmm... I could debug this by recreating the conditions on a smaller
scale. So how do I do that? I need to use the same range parameters... Hmm... I mean I could theoretically recreate this. Although I do have the stack and all the various function calls
to help me debug everything... 

12/24/2020
Okay... so what to do here? It looked to be occurring in the 3rd sub-cycle. I should run the code to try and re-create that issue... Hmm... This is bizarre... It might be some sort of a
memory reference thing based on how music21 handles the various object references. Although I thought I returned all new objects/deep copies each time... Perhaps I went wrong somewhere...
Hmm... How could I test this? I could generate each cycle independently... Hmm... Or I might have already checked that in a way with the other code where I was able to generate the
cycle pair successfully... However in that case I didn't do any sort of range checking... So hmm... I should definitely run it just on the cycle three and then the cycle6 with
ranges enforced to see if the results are correct. From there we can see what the differences in the executions are to isolate where the bug might be...

Ahaha! I believe I have found the bug! Hmm... I think I understand why this is occurring... This is becasue the chord_as_list object only transposes the notes if there is a non-zero
element in the row for that particular voice. Given that we generate a chord based on the pitches currently in the list, and we don't always have unique values in them on each iteration
(i.e. common chord tones don't change between one chord and the next) we don't have unique pitches across the spectrum. This means later on if a chord is out of range and needs to be
transposed, that any of the other pre-existing chords who have this music21 pitch object in them will also have their pitch value transposed since things operate by memory references
in music21...

Hmm... seems like you've got it now but it also seems like you have an issues with the starting/ending chords for the 3/6 cycles... It would also be good to test this with all the 
various possible keys and chord voicings. However that might take some time and is probably something best left to being done with a guitar in hand to make sure everything works
as intended. Then we could try them out on the guitar... Hmm... Although having these as a mental exercise is extremely useful as well... Hmm... so what to do now? I can focus on the
other aspects like making sure the .xml files are done correctly as well as the code is clean in general...

So how do I do this? There's a path which is necessary. This will point to the directory in which the XML files should be output. A default path should be specified... Hmm... I'm not
sure if it's possible to create variables with all these different strings already specified earlier so the title and filename can be generated from the same set of data to simplify
things.

12/27/2020
Okay... So what to do here? Focus on getting the output files working and done first...
Hmm... Although how do I want to do this? It would be nice if I could create an output
file for any arbitrary cycle. This way I wouldn't be relegated to specifically the function
which generates all the permuatations on the string sets... Ultimately this would be a
lot more modular and support more functionality. Anyone could generate a cycle and then
pass it as a function to export it. That makes a lot more sense. So what do we need here
then? We need a function which takes a cycle and a path to a directory where it saves
the .XML file for the cycle. Hmm... I mean really this isn't too complicated and this
functionality is common enough that it warrants it's own function. This function would
have to extract all the meta-data from the cycle to be able to generate the title...
That's a good point...

Now we need to figure out how to extract the various pieces of information from the
metadata to generate the file name here... Hmm... so I will have to take the metadata
title and figure out how to format it to make sure it can be written as a file. this
shouldn't be too hard... just some basic string processing and conversion methods...

Hmm... what do we need to do? Remove the // from the "Cycle" signifier as that will  
inadvertnetly end up creating a directory

1. Remove // from cycle signifier
2. 

Hmm... what do I want it to look like?

Cycle 36 Progression in C major; String Set 4-3-1; Drop 2 Triads

That seemed straight forward enough... hmm... What about this part now? I need to figure
out how to get these starting chords to be correct. One thing which I don't do is check 
to make sure the starting chord is within range on the current strings. This seems to be
a corner case where the starting note belongs to the upper range one the lowest string.
Hmm... Also, this shape in and of itself as outside the range... This needs to be 
fixed...

Hmm... This range checking/transposition function doesn't seem to be working...
Hmm... I see what's going on here... This is really a hard thing to describe in terms
of determing what frets to restrict things to... Although theoretically I could write
a function/logic which analyzes the chord voicing as well as string set and then ensures
that there's only one voicing per string set. From there this logic would make the
generated cycles a lot more coherent in a certain sense... I'd have to look at the
range of the intervals in the different voicings to solve this one entirely...

Hmm... although it might be useful to have some sort of a function or return value which
tells you if it's impossible to get the voicing to work on the specified string range...
This all really depends on the different voicings you use as well as the strings selected.

Hmm... I mean for now I can work on each output file as I use them... It would take a
long time to figure this out... well maybe not a long time but it would be something i
need to sit out and design and i don't have the mental space for it now... I think I'm
definitely at the point where I can start generating different cycles to practice with
and this will help me debug the code and figure out the different test cases needed to
re-create the issues... This is good enough for the moment...

02/18/2021
Hmm... I think I'm definitely leaning more towards the Chris Buono approach of not using open strings to practice this... Hmm... I also feel a bit of pain in my hand so that's probably
a good sign I shouldn't be doing any sort of technical exercises like that on guitar... Hmm... So I think I've fixed that issue... It was more that I didn't specify the parameters 
correctly I believe... Damn... I think all my guitars definitely need a setup at this point in time. And my acoustic definitely needs some TLC... Those guys should probably be kept
in their cases with a good humidifier there to keep them from drying out... I'll need to look into something like that... Hmm... How many more different test cases should I run here?
It would probably be good to run one on each of the different string sets and quickly double check the fingerings generated... What is the deal with this ending chord here? Why would
it be up an octave? Hmm... It takes a copy of the last chord and copies that in... Hmm... So this is what? It seems to me something is modifying that chord there... Hmm... How do I 
solve this? I could find where the chord is being modified or save a copy of the last chord before hand... Hmm... I would prefer to not have any of these functions modify anything...
Hmm... I think i should rework this generate tonic triad function to generate the chord to appear on the lowest set of frets possible... Hmm... Or perhaps there's a way to ensure 
there's only one possible chord voicing for each one? Hmm... But then given that we're dealing with drop2 triads here the voicings have a much larger range. But then I'm not sure if
it will be possible to generate a fingering for each of the different... So I believe I've fixed that last chord copy issue... Hmm... Now I'll have to test this out for closed voicings
as well as the other different cycles... Goddamn... That's a lot of testing... Although if I write out the test cases first it won't be too bad as I'll have a much better idea of what
to do... 

Hmm... Strange chord here for the starting chord... Ahh... I was incorrect... It's much more the second chord which has the issue with it... Hmm... Definitely this range checking and transposition feature needs to be checked in
order to ensure we get voice-leading patterns that make sense... I'm not sure if this is ready to be released just yet... However I'll have to think out the different aspects associated with the range checking/transposition feature
in general. This should be an interesting/complex problem to get involved with...

04/09/2021
Hmmm... Okay... Let's try and get this sorted out and more finalized so I could release it and use it myself (once my arms heal). Hmm... So I'm still getting that bug here... Or at
least some sort of a strange bug regarding the transposition when chords are determined to be out of range... Hmm... Okay... So that first one technically wasn't an error. The G is
out of bounds as we're not using the open strings here. However the second chord should be down an octave to emphasize the reverse order from before. Hmm... I could fix this here for
this particular chord cycle however it's not clear to me this might cause problems later on... However it would be good to take the smallest change possible and then see how it changes
everything... However this involves manually going through the different output to make sure it works... That's pretty tedious in and of itself... There has to be a better way to analyze
these things and I think it has to do with the different intervals involved in the chord and the particular strings selected and how they manifest themselves... Hmmm... I mean it would
be nice if this worked for other types of chords beyond just the ones specified here... I would need a more generalized method for this which was intelligent enough to determine the
largest intervals in the chords... or hmm... it might not even be that necessary... hmm... there might also be other methods which could be explored... I might be able to keep track of
if it's being done during an ascending part or a descending part... hmm... although maybe not... the same issue could occur in the middle of a measure... suppose you have an ascending
line of chords and the same thing happens... hmm... so what do we do here...? Is there a way we could focus on just the bass note? Hmm... I don't think so as we have situations where
only one note changes at once. That's the situation we have here... And that's what the basic algorithm currently in place does. It checks to make sure that all the notes currently
in the chord are in range for the sets of strings selected. Hmm... given that we have a larger variation in chord voicings (compared to the closed triad version which Buono created)
it would be harder to do this purely through the range avaialble on the strings. I think more what I want to do is ensure that there's onyl one unique voicing for each chord in each
cycle. That was the goal of the cycles and ranges to some extent... Hmm... Perhaps developing another condition would be necessary... How would we enforce this uniqueness aspect? And
do we want to favor the upper end or the lower end of the range? Perhaps it would be easy to develop both... Although for now focus on developing the lower end of the spectrum... Hmm...
We could also use programming invariants to check the final output and make sure things are correct as we expect them to be... But let's condsider that other scenario... Perhaps 
generating what we know to be the lowest possible chord for the given root and string set would be beneficial. Then we could use this impose another transposition condition. If we
end up with a chord that is an octave higher than this, then we know we should transpose it downwards. Hmm... I mean you could do something similar to make it work for the upperbound...
Or if you were going in reverse... Although that should be a fairly hard limit I think based on the nature of the strings in general... Hmm... So I think creating this upper limit chord
and using that for comparison within the check and transpose functions would be the next step... Hmm... but then the question becomes how do I generate the upper chord for each of
the different cycles? That's a good question itself... I mean in this case it works out that the first chord is the highest chord. This is clearly not always the case... We would have
to know basically the entire cycle it almost seems. Well we would need to know what the lowest note we could play is and what the corresponding chord is. Unfortuantely we don't necessarily
know the chord unless the entire cycle has been generated. Although I suppose I could deduce/calculate it based on the other information we have on the chord but how much work is that
compared to scanning through the finalized generated sequences...? That's a good question... Hmm... it's beginning to seem like it might be easier to enforce the uniqueness aspect after
generating the entire sequence. It would be somewhat of more of a post-processing type of thing. So we find the lowest chord in the entire sequence. Then we scan through the rest of the
sequence to make sure that none of the chords are an octave above it. Hmm... We could also theoretically do this in reverse but use the highest possible chord... I believe the stream
structure lends itself extremely well to this... well I'm fairly certain I know how to do this now it's just a matter of writing it out...

Steps:

1. Scan through the cycle to find the lowest chord
2. Scan through again to ensure that no chords are an octave or more above it.
3. If found then transpose accordingly

Hmm... There's a few different things here. I mean we are using Chord objects here. Figuring out how to do the comparison between two Chord objects would be necessary. Hmmm... So I can
get all of the Chords in a stream. Depending on how things are organized within the various stream objects this could be extremely beneficial... Hmmm... It seems as if I can get the
notes from the chords and do the comparisons individually... Pitches is more what we want as it contains the octave information...

04/10/2021
Hmm... So it seems as if you don't really need anything more than a stream in this case. the stream provides the upper/lower limit itself... Hmm... so we need a way to find the 
highest/lowest chord in the stream. That shouldn't be too hard, it would just be necessary to develop the conditions to establish this. we can get all the chords in a stream and
since music21 stores things by reference (and we don't plan on doing any sort of editing to this chord/music21 object) it should be sufficient to just grab all the chords and compare
them one by one... although there's probably a better method for this... however... Hmm... i mean we can't really assume anything regarding how these chords are stored in the streams...
this would be some good old fashioned unsorted data... Hmm... So how should this compare chords function work? What are the possible scenarios? 
	1. chord 1 is higher than chord 2
	2. chord 1 is the same as chord 2
	3. chord 1 is lower than chord 2
	
So how are we defining lower and higher here? Hmm... For now lets just stick to dealing with chords that have the same number of notes. In this case in order to consider a chord higher
than another chord we would need to make sure at least one of its chord tones is higher than the others... hmm... perhaps that isn't worded correctly... so each chord has the same number
of notes... Hmm... Also I would need to access the pitches attribute to be able to do this but thankfully the pitches class implements the comparison operators... So how do we define
the higher/lower concepts here in terms of the comparison function... hmm... i mean i could overload the comparison functions technically... in a way that's what i'm looking for here...
Hmm... It seems they've already done the equality operator for chords... Although I'm not sure how the comparison is done here... hmm... I mean having this notition of using the same
actual instances fo each object in the cycles would be nice... technically all the cycles really are are the same chords in a different arrangement... Generating the cycles via modifying
existing streams could be beneficial... hmm... this chord comparison function is more complicated than i had imagined at first... so what are the conditions necessary for a chord
to be considered higher? all of the notes need to be the same and at least one note is higher? say you have n notes total. n-1 notes need to be the same and 1 needs to be higher...
hmm... perhaps there's something in set operations which would help facilitate this further... Hmm... Or it seems as if there are list comparisons... I should investigate that more...
hmm... this problem just seems really messy in general and there's no easy way to solve it... although some of the element wise comparison functions in matlab would really be nice here...
perhaps there is similar functionality for lists... There might be a way to do thise by equating true/fasle with 1/0 and summing over the values... i believe that should handle things
nicely... Hmmm... So it seems if the sum function should be able to do this to a list. I also have the np library if need be... Hmm... So lets see here... I would need to go through
and compare all the pitches... So let's see here... How do I go about doing this...? it all depends on the comparison function used... Hmm... it already treats true/false as 1/0 when
putting the list into sum... that's nice... now the next step is to figure out how to interepret the results of the summation for our purposes here...

if all the notes are greater in chord_1 then the sume will be 3
if two of the notes are greater in chord_1 then the sum will be 2
if 1 of the notes are greater in chord_1 then the sum will be 1

Hmm... what about the scenario where the notes are the same? we're missing out on that one here... However at this point in the function we can assume that the chords aren't the same
as we do that comparison first... this means the chords differ at least by 1 pitch... so that means we could use the >= function... or does it? i mean why would we need to use it?
ahh... we need to consider when they differ by one note... hmm... or do we... suppose we have the chords ACE and ACF. The first two will return false and the third will return true...
well no... I'm thinking in reverse here... they all will return false... and this would be true since technically the chord would be lower... but since we now know that the chords 
differ by at least one note, it's a matter of finding that note in a way... hmm... i mean damn... this is acutally a tricky concept to define well when you think about it as there
as so many different possibilities for figuring out how to define this... I mean there are many different ways you could try and figure out how to define the differences in the chord
ranges/sizes here... Interesting... This is where more precisely defining the criteria would be necessary here... That will give it an unambiguous manner for interpretation/definition...

04/11/2021
Hmmm... Okay... lets continue developing this algorithm... Hmm... so at this point we know the chords differ by at least one pitch... What do we then do with this information? We use
it to figure out how to interpret the results of the comparison function... So how do we interpret this greater than function in the conext of at least one of the notes being different?
Well if it returns all false then that means each of the pitches in chord_1 is less than or equal to all the pitches in chord_2. However at the same time since at least one chord tone
is different then if all are false then at least one of these chord tones is lower and the rest are equal or lower so that would then make it so chord_1 is "lower" than chord_2. Hmm...
It might be possible to make this more efficient... What about the case where at least one note is greater? Hmm... So I'm fairly confident I have the comparison function working correctly...
Let's get back to the overall algorithm... I first need to go through and find the lowest chord in the sequence. This should work for all streams since a stream just contains another
stream... Well we'll see I reckon...

So now I need to go through and find the lowest chord in the stream... hmm... this doesn't seem go dive deeper into the structures of the streams at all... Hmm... So it appears as if
I need to flatten the stream first or use the recurse method... Hmm... I'm more partial to the recurse method myself as it doesn't destroy the underlying data structure and I'd have
the ability to display which sub-structure I'm exploring first...

Hmm... So this is getting more complicated than I thought... If I was to make a more generic one then this would take longer... But there are assumptions I can make regarding the
composition of the incoming streams... I will know what those are. I mean either we get a sub-cycle, a full cycle or a cycle pair. a sub-cycle is contained within a measure. a full
cycle contains multiple sub-cycles (stored in measures) but is inherently a stream itself. Hmm... And a cycle pair... A cycle pair is a stream which contains two cycles... So before
we operate here we should establish which type of structure we're dealing with. In order to do this I'll need to check the depth of the stream... Hmm... well maybe... There seems to
be a class filter as part of the function signature... Hmm... yes... This will do much better... hmm... so what do we do now... Hmm... how do we do this in terms of initializing things?
We need to have the first chord become the lowest chord... how do we do that? or we could set this to be the highest possible chord representable with this... hmm... did it the other
way...

hmm... so... lets see here... lowest holds the current "lowest" chord. this is intialized as the first chord... so then we go and compare it to the rest of the chords... well we compare
the lowest with the next chord. given that we have unsorted data this is one way... hmm... don't worry too much about it at the moment... but lets see here... so we compare it to the
next chord and if that chord is "lower" then the lowest variable is set to that... hmm... so lowest always contains the currently established lowest chord... hmm... after it iterates
through the entire length of chords then it is guaranteed to be the lowest chord... hmm... how could i test this? plug a stream into it and make sure it returns the lowest chord...
hmm... so this seems to work...

hmm... so how is this going to operate? well will it take a cycle? a sub-cycle? a cycle-pair? Hmm... It would be nice if it was able to operate on all of them... well perhaps it can
since i believe we will be given references to the music21 objects and this would be useful... hmm.... could we do this at the same time as when we find the min? well maybe but I don't
want to think about it now... I'd prefer separating this functionality anyways... So now how do we use this? If this is the defined lowest chord then we need to make sure that if
we find any chord which is greater than or equal to the octave transposition of it is tranposed down an octave so we have a unique set of chords in that there's only one voicing for
each...

Hmm... So how does this work... If a chord isn't lower than the upper bound (which is the lowest chord transposed up an octave) then we need to transpose that chord down an octave...
Hmm... But given that the chord is either the same as the lowest chord (transposed) or at least one of it's notes is higher than we know that transposing it down an octave will have
a fingering/voicing which is consistent with the lower range bournd as defined by the guitar strings... Interesting... I'm fairly confident this will work so lets give it awhirl...

Hmm... I mean this honestly seems like its solved the issue... Given that we're not using open strings then this chord is voiced in the appropriate manner i would say... well that's a
nice chunk of functionality to check off... Hmm... Although I mean I think ideally I would add this to the cycle pair or the cycles function... hell... or any of the functions to 
make sure the range checking is done correctly on the various strings... I'd need to re-write the function which tests the "ensure" unique aspect but that's not too bad... man... this
really makes me miss writing sogtware in general...

04/14/2021
Hmm... Okay... So lets see here... so where should I put this code to check to ensure the chords are unique? this should only happen if there's a note range or something I think...
that's definitely what it seems like... Hmm... Perhaps it should be another flag or optoin? I mean what if you don't mind things going beyond a specific range? That's a good point...
Yeah, I think this would be best as something which could be use afterwards... Or hmm... it definitely should be applied if there's any sort of a string set... That was the entire
point... However I'm sure that other people might be able to use it and figure it out... hmm... for now let's have it called afterwards for something that wasn't specifically meant
for generating the cycles for a particular set of strings... 

Hmm... why is it saying the list object has no attribute called recurse? interesting... i'm not sure... i mean it was clearly passed a stream... or it was called
on a stream itself... where is this exception being generated? inside the music21 library or something from my code? ahh... it's because it's a list of streams... not a stream of
streams... Now to verifiy everytrhing is being generated correctly...

04/15/2021
Hmm... It seems as if the range checking didn't get this chord here... Hmm... So when I generate it in isolation the transposition occurs, but not when doing the full string set...
I wonder why... Perhaps placement in the generation function? Hmm... I should give my hands a rest for a bit and then I can resume verifying all these different chord progressions...
I was getting the tingley sensation a bit...

04/17/2021
Aha! Found an error in the 2/7 generated forthe 5-4-3 string set... The last chord is an octave lower than it should be... I think I see the error here... The tonic triad attached 
to the end doesn't go through any sort of error checking to make sure it is within range... I should do that...

So what would be some good ways to showcase what this software can generate?
 1. Examples of each of the different cycle types without any sort of range checking
	Cycle 2/7
	Cycle 5/4
	Cycle 3/6
 2. Take one of the examples and apply it to different string sets to show how it can be applied
 3. Generate a drop 2 version of one of the voicings
 4. Apply this to the different forms available for the guitar string sets
 
Hmm... The drop 2 functionality doesn't work with this modified tonality... Damn... Perhaps it has to do with the string sets... I'm not sure...

*05/27/2021*
Hmm... Okay... So why isn't the harmonic minor stuff working for the drop 2 scenario... Lets take another stab at that... Hmm... I think it might have to do with the that I'm passing
in a closed triad as opposed to a drop2 voicing... Yup... It all seems to work now... horray! It's probably also worth developing the documentation a bit more to make it easier to
understand for people much more easily...

*06/11/2021*
Okay... So what to do here in terms of being able to explain these ideas? It would be worth going through the basics here with some examples. Start with the basics of what a drop2
cycle is and go through showing how you extracted out the different rules...
